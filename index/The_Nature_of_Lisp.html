<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2&nbsp;The Nature of Lisp</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">&#34479;&#40071;&#34573;&#30340;&#21338;&#23458;</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="The_Hy_Programming_Language.html" class="tocviewlink" data-pltdoc="x">The Hy Programming Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">The Nature of Lisp</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="The_Nature_of_Lisp__Cursor_Translated.html" class="tocviewlink" data-pltdoc="x">The Nature of Lisp, Cursor Translated</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="The_Nature_of_Lisp_Translated_.html" class="tocviewlink" data-pltdoc="x">The Nature of Lisp(Translated)</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="THE_ROBOT_AND_THE_BABY.html" class="tocviewlink" data-pltdoc="x">THE ROBOT AND THE BABY</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="What_is_Racket.html" class="tocviewlink" data-pltdoc="x">What is Racket</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="First_Racket_Program.html" class="tocviewlink" data-pltdoc="x">First Racket Program</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="Basic_Grammar.html" class="tocviewlink" data-pltdoc="x">Basic Grammar</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Conditions_and_Procedures.html" class="tocviewlink" data-pltdoc="x">Conditions and Procedures</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Lists.html" class="tocviewlink" data-pltdoc="x">Lists</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Recursion.html" class="tocviewlink" data-pltdoc="x">Recursion</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="High-Order_Functions.html" class="tocviewlink" data-pltdoc="x">High-<wbr></wbr>Order Functions</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Vectors__Strings_and_Structures.html" class="tocviewlink" data-pltdoc="x">Vectors, Strings and Structures</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="quote.html" class="tocviewlink" data-pltdoc="x">quote</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="Macros.html" class="tocviewlink" data-pltdoc="x">Macros</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Language-Oriented_Programming.html" class="tocviewlink" data-pltdoc="x">Language-<wbr></wbr>Oriented Programming</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Appendix.html" class="tocviewlink" data-pltdoc="x">Appendix</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Cursor_s_Racket_Tutorial.html" class="tocviewlink" data-pltdoc="x">Cursor&rsquo;s Racket Tutorial</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="Eternal_Flame.html" class="tocviewlink" data-pltdoc="x">Eternal Flame</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">The Nature of Lisp</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#%28part._.Introduction%29" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#%28part._.X.M.L_.Reloaded%29" class="tocviewlink" data-pltdoc="x">XML Reloaded</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#%28part._.Ant_.Reloaded%29" class="tocviewlink" data-pltdoc="x">Ant Reloaded</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="#%28part._.Why_.X.M.L_%29" class="tocviewlink" data-pltdoc="x">Why XML?</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="#%28part._.Almost_.Lisp%29" class="tocviewlink" data-pltdoc="x">Almost Lisp</a></td></tr><tr><td align="right">2.6&nbsp;</td><td><a href="#%28part._.A_.Better_.X.M.L%29" class="tocviewlink" data-pltdoc="x">A Better XML</a></td></tr><tr><td align="right">2.7&nbsp;</td><td><a href="#%28part._.C_.Macros_.Reloaded%29" class="tocviewlink" data-pltdoc="x">C Macros Reloaded</a></td></tr><tr><td align="right">2.8&nbsp;</td><td><a href="#%28part._.Hello__.Lisp_%29" class="tocviewlink" data-pltdoc="x">Hello, Lisp!</a></td></tr><tr><td align="right">2.9&nbsp;</td><td><a href="#%28part._.Lisp_.Macros%29" class="tocviewlink" data-pltdoc="x">Lisp Macros</a></td></tr><tr><td align="right">2.10&nbsp;</td><td><a href="#%28part._.Domain_.Specific_.Languages%29" class="tocviewlink" data-pltdoc="x">Domain Specific Languages</a></td></tr><tr><td align="right">2.11&nbsp;</td><td><a href="#%28part._.What_s_next_%29" class="tocviewlink" data-pltdoc="x">What&rsquo;s next?</a></td></tr><tr><td align="right">2.12&nbsp;</td><td><a href="#%28part._.Comments_%29" class="tocviewlink" data-pltdoc="x">Comments?</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Introduction%29" class="tocsubseclink" data-pltdoc="x">Introduction</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.X.M.L_.Reloaded%29" class="tocsubseclink" data-pltdoc="x">XML Reloaded</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Ant_.Reloaded%29" class="tocsubseclink" data-pltdoc="x">Ant Reloaded</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Why_.X.M.L_%29" class="tocsubseclink" data-pltdoc="x">Why XML?</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#%28part._.Almost_.Lisp%29" class="tocsubseclink" data-pltdoc="x">Almost Lisp</a></td></tr><tr><td><span class="tocsublinknumber">2.6<tt>&nbsp;</tt></span><a href="#%28part._.A_.Better_.X.M.L%29" class="tocsubseclink" data-pltdoc="x">A Better XML</a></td></tr><tr><td><span class="tocsublinknumber">2.7<tt>&nbsp;</tt></span><a href="#%28part._.C_.Macros_.Reloaded%29" class="tocsubseclink" data-pltdoc="x">C Macros Reloaded</a></td></tr><tr><td><span class="tocsublinknumber">2.8<tt>&nbsp;</tt></span><a href="#%28part._.Hello__.Lisp_%29" class="tocsubseclink" data-pltdoc="x">Hello, Lisp!</a></td></tr><tr><td><span class="tocsublinknumber">2.9<tt>&nbsp;</tt></span><a href="#%28part._.Lisp_.Macros%29" class="tocsubseclink" data-pltdoc="x">Lisp Macros</a></td></tr><tr><td><span class="tocsublinknumber">2.10<tt>&nbsp;</tt></span><a href="#%28part._.Domain_.Specific_.Languages%29" class="tocsubseclink" data-pltdoc="x">Domain Specific Languages</a></td></tr><tr><td><span class="tocsublinknumber">2.11<tt>&nbsp;</tt></span><a href="#%28part._.What_s_next_%29" class="tocsubseclink" data-pltdoc="x">What&rsquo;s next?</a></td></tr><tr><td><span class="tocsublinknumber">2.12<tt>&nbsp;</tt></span><a href="#%28part._.Comments_%29" class="tocsubseclink" data-pltdoc="x">Comments?</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.8</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="The_Hy_Programming_Language.html" title="backward to &quot;1 The Hy Programming Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;蚯鲇蜍的博客&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="The_Nature_of_Lisp__Cursor_Translated.html" title="forward to &quot;3 The Nature of Lisp, Cursor Translated&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>2<tt>&nbsp;</tt><a name="(part._.The_.Nature_of_.Lisp)"></a>The Nature of Lisp</h3><p><span class="Smaller">Monday, May 8, 2006</span></p><blockquote class="SCentered"><p>&#26412;&#25991;&#36716;&#33258;<a href="#">defmacro.org</a>, &#20316;&#32773;Slava Akhmechet</p></blockquote><h4>2.1<tt>&nbsp;</tt><a name="(part._.Introduction)"></a>Introduction</h4><p>When I first stumbled into Lisp advocacy on various corners of the web I was
already an experienced programmer. At that point I had grokked what seemed at
the time a wide range of programming languages. I was proud to have the usual
suspects (C++, Java, C#, etc.) on my service record and was under impression
that I knew everything there is to know about programming languages. I
couldn&rsquo;t have possibly been more wrong.</p><p>My initial attempt to learn Lisp came to a crashing halt as soon as I saw
some sample code. I suppose the same thought ran through my mind that ran
through thousands of other minds who were ever in my shoes: "Why on Earth would
anyone want to use a language with such horrific syntax?!" I couldn&rsquo;t be bothered
to learn a language if its creators couldn&rsquo;t be bothered to give it a pleasant
syntax. After all, I was almost blinded by the infamous Lisp parentheses!</p><p>The moment I regained my sight I communicated my frustrations to some members
of the Lisp sect. Almost immediately I was bombarded by a standard set of
responses: Lisp&rsquo;s parentheses are only a superficial matter, Lisp has a huge
benefit of code and data being expressed in the same manner (which, obviously,
is a huge improvement over XML), Lisp has tremendously powerful metaprogramming
facilities that allow programs to write code and modify themselves, Lisp allows
for creation of mini-languages specific to the problem at hand, Lisp blurs the
distinction between run time and compile time, Lisp, Lisp, Lisp... The list was
very impressive. Needless to say none of it made sense. Nobody could illustrate
the usefulness of these features with specific examples because these techniques
are supposedly only useful in large software systems. After many hours of debating
that conventional programming languages do the job just fine, I gave up. I wasn&rsquo;t
about to invest months into learning a language with a terrible syntax in order
to understand obscure features that had no useful examples. My time has not yet come.</p><p>For many months the Lisp advocates pressed on. I was baffled. Many extremely
intelligent people I knew and had much respect for were praising Lisp with almost
religious dedication. There had to be something there, something I couldn&rsquo;t afford
not to get my hands on! Eventually my thirst for knowledge won me over. I took
the plunge, bit the bullet, got my hands dirty, and began months of mind bending
exercises. It was a journey on an endless lake of frustration. I turned my mind
inside out, rinsed it, and put it back in place. I went through seven rings of hell
and came back. And then I got it.</p><p>The enlightenment came instantaneously. One moment I understood nothing, and the
next moment everything clicked into place. I&rsquo;ve achieved nirvana. Dozens of times
I heard Eric Raymond&rsquo;s statement quoted by different people: "Lisp is worth learning
for the profound enlightenment experience you will have when you finally get it;
that experience will make you a better programmer for the rest of your days, even
if you never actually use Lisp itself a lot." I never understood this statement. I
never believed it could be true. And finally, after all the pain, it made sense!
There was more truth to it than I ever could have imagined. I&rsquo;ve achieved an almost
divine state of mind, an instantaneous enlightenment experience that turned my view
of computer science on its head in less than a single second.</p><p>That very second I became a member of the Lisp cult. I felt something a ninjitsu
master must feel: I had to spread my newfound knowledge to at least ten lost souls
in the course of my lifetime. I took the usual path. I was rehashing the same
arguments that were given to me for years (only now they actually made sense!),
hoping to convert unsuspecting bystanders. It didn&rsquo;t work. My persistence sparked
a few people&rsquo;s interest but their curiosity dwindled at the mere sight of sample
Lisp code. Perhaps years of advocacy would forge a few new Lispers, but I wasn&rsquo;t
satisfied. There had to be a better way.</p><p>I gave the matter careful thought. Is there something inherently hard about Lisp
that prevents very intelligent, experienced programmers from understanding it? No,
there isn&rsquo;t. After all, I got it, and if I can do it, anybody can. Then what is it
that makes Lisp so hard to understand? The answer, as such things usually do, came
unexpectedly. Of course! Teaching anybody anything involves building advanced
concepts on top of concepts they already understand! If the process is made
interesting and the matter is explained properly the new concepts become as
intuitive as the original building blocks that aided their understanding. That was
the problem! Metaprogramming, code and data in one representation, self-modifying
programs, domain specific mini-languages, none of the explanations for these
concepts referenced familiar territory. How could I expect anyone to understand
them! No wonder people wanted specific examples. I could as well have been
speaking in Martian!</p><p>I shared my ideas with fellow Lispers. "Well, of course these concepts aren&rsquo;t
explained in terms of familiar territory", they said. "They are so different,
they&rsquo;re unlike anything these people have learned before." This was a poor excuse.
"I do not believe this to be true", I said. The response was unanimous: "Why don&rsquo;t
you give it a try?" So I did. This article is a product of my efforts. It is my
attempt to explain Lisp in familiar, intuitive concepts. I urge brave souls to read
on. Grab your favorite drink. Take a deep breath. Prepare to be blown away. Oh, and
may the Force be with you.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.X.M.L_.Reloaded)"></a>XML Reloaded</h4><p>A thousand mile journey starts with a single step. A journey to enlightenment
is no exception and our first step just happens to be XML. What more could
possibly be said about XML that hasn&rsquo;t already been said? It turns out, quite
a bit. While there&rsquo;s nothing particularly interesting about XML itself, its
relationship to Lisp is fascinating. XML is the all too familiar concept that
Lisp advocates need so much. It is our bridge to conveying understanding to
regular programmers. So let&rsquo;s revive the dead horse, take out the stick, and
venture into XML wilderness that no one dared venture into before us. It&rsquo;s time
to see the all too familiar moon from the other side.</p><p>Superficially XML is nothing more than a standardized syntax used to express
arbitrary hierarchical data in human readable form. To-do lists, web pages, medical
records, auto insurance claims, configuration files are all examples of potential
XML use. Let&rsquo;s use a simple to-do list as an example (in a couple of sections you&rsquo;ll
see it in a whole new light):</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;todo</span><span class="hspace">&nbsp;</span><span class="RktMeta">name="housework"&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;item</span><span class="hspace">&nbsp;</span><span class="RktMeta">priority="high"&gt;Clean</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">house.&lt;/item&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;item</span><span class="hspace">&nbsp;</span><span class="RktMeta">priority="medium"&gt;Wash</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">dishes.&lt;/item&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;item</span><span class="hspace">&nbsp;</span><span class="RktMeta">priority="medium"&gt;Buy</span><span class="hspace">&nbsp;</span><span class="RktMeta">more</span><span class="hspace">&nbsp;</span><span class="RktMeta">soap.&lt;/item&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/todo&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>What happens if we unleash our favorite XML parser on this to-do list? Once the data
is parsed, how is it represented in memory? The most natural representation is, of
course, a tree - a perfect data structure for hierarchical data. After all is said
and done, XML is really just a tree serialized to a human readable form. Anything
that can be represented in a tree can be represented in XML and vice versa. I hope
you understand this idea. It&rsquo;s very important for what&rsquo;s coming next.</p><p>Let&rsquo;s take this a little further. What other type of data is often represented as a
tree? At this point the list is as good as infinite so I&rsquo;ll give you a hint at what
I&rsquo;m getting at - try to remember your old compiler course. If you have a vague
recollection that source code is stored in a tree after it&rsquo;s parsed, you&rsquo;re on
the right track. Any compiler inevitably parses the source code into an abstract
syntax tree. This isn&rsquo;t surprising since source code is hierarchical: functions
contain arguments and blocks of code. Blocks of code contain expressions and statements.
Expressions contain variables and operators. And so it goes.</p><p>Let&rsquo;s apply our corollary that any tree can easily be serialized into XML to this idea.
If all source code is eventually represented as a tree, and any tree can be serialized
into XML, then all source code can be converted to XML, right? Let&rsquo;s illustrate this
interesting property by a simple example. Consider the function below:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">int</span><span class="hspace">&nbsp;</span><span class="RktMeta">add(int</span><span class="hspace">&nbsp;</span><span class="RktMeta">arg1,</span><span class="hspace">&nbsp;</span><span class="RktMeta">int</span><span class="hspace">&nbsp;</span><span class="RktMeta">arg2)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta">arg1</span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">arg2;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Can you convert this function definition to its XML equivalent? Turns out, it&rsquo;s
reasonably simple. Naturally there are many ways to do this. Here is one way the
resulting XML can look like:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;define-function</span><span class="hspace">&nbsp;</span><span class="RktMeta">return-type="int"</span><span class="hspace">&nbsp;</span><span class="RktMeta">name="add"&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;arguments&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;argument</span><span class="hspace">&nbsp;</span><span class="RktMeta">type="int"&gt;arg1&lt;/argument&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;argument</span><span class="hspace">&nbsp;</span><span class="RktMeta">type="int"&gt;arg2&lt;/argument&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;/arguments&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;body&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;return&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;add</span><span class="hspace">&nbsp;</span><span class="RktMeta">value1="arg1"</span><span class="hspace">&nbsp;</span><span class="RktMeta">value2="arg2"</span><span class="hspace">&nbsp;</span><span class="RktMeta">/&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;/return&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;/body&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/define&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We can go through this relatively simple exercise with any language. We can turn
any source code into XML, and we can transform the resulting XML back to original
source code. We can write a converter that turns Java into XML and a converter
that turns XML back to Java. We could do the same for C++. (In case you&rsquo;re wondering
if anyone is crazy enough to do it, take a look at <a href="#">GCC-XML</a>).
Furthermore, for languages that share common features but use different
syntax (which to some extent is true about most mainstream languages) we
could convert source code from one language to another using XML as an
intermediary representation. We could use our Java2XML converter to convert
a Java program to XML. We could then run an XML2CPP converter on the
resulting XML and turn it into C++ code. With any luck (if we avoid using
features of Java that don&rsquo;t exist in C++) we&rsquo;ll get a working C++ program.
Neat, eh?</p><p>All this effectively means that we can use XML for generic storage of source code.
We&rsquo;d be able to create a whole class of programming languages that use uniform syntax,
as well as write transformers that convert existing source code to XML. If we were to
actually adopt this idea, compilers for different languages wouldn&rsquo;t need to implement
parsers for their specific grammars - they&rsquo;d simply use an XML parser to turn XML
directly into an abstract syntax tree.</p><p>By now you&rsquo;re probably wondering why I&rsquo;ve embarked on the XML crusade and what it
has to do with Lisp (after all, Lisp was created about thirty years before XML). I
promise that everything will become clear soon enough. But before we take our second
step, let&rsquo;s go through a small philosophical exercise. Take a good look at the XML
version of our "<span class="RktSym">add</span><span class="RktMeta"></span>" function above. How would you classify it? Is it data or code?
If you think about it for a moment you&rsquo;ll realize that there are good reasons to put
this XML snippet into both categories. It&rsquo;s XML and it&rsquo;s just information encoded in
a standardized format. We&rsquo;ve already determined that it can be generated from a tree
data structure in memory (that&rsquo;s effectively what GCC-XML does). It&rsquo;s lying around in
a file with no apparent way to execute it. We can parse it into a tree of XML nodes
and do various transformations on it. It&rsquo;s data. But wait a moment! When all is said
and done it&rsquo;s the same "<span class="RktSym">add</span><span class="RktMeta"></span>" function written with a different syntax, right? Once
parsed, its tree could be fed into a compiler and we could execute it. We could easily
write a small interpreter for this XML code and we could execute it directly.
Alternatively, we could transform it into Java or C++ code, compile it, and run it.
It&rsquo;s code.</p><p>So, where are we? Looks like we&rsquo;ve just arrived to an interesting point. A concept that
has traditionally been so hard to understand is now amazingly simple and intuitive. Code
is also always data! Does it mean that data is also always code? As crazy as this sounds
this very well might be the case. Remember how I promised that you&rsquo;ll see our to-do list
in a whole new light? Let me reiterate on that promise. But we aren&rsquo;t ready to discuss
this just yet. For now let&rsquo;s continue walking down our path.</p><p>A little earlier I mentioned that we could easily write an interpreter to execute our XML
snippet of the <span class="RktSym">add</span><span class="RktMeta"></span> function. Of course this sounds like a purely theoretical exercise.
Who in their right mind would want to do that for practical purposes? Well, it turns out quite
a few people would disagree. You&rsquo;ve likely encountered and used their work at least once
in your career, too. Do I have you out on the edge of your seat? If so, let&rsquo;s move on!</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Ant_.Reloaded)"></a>Ant Reloaded</h4><p>Now that we&rsquo;ve made the trip to the dark side of the moon, let&rsquo;s not leave quite yet.
We may still learn something by exploring it a little more, so let&rsquo;s take another step.
We begin by closing our eyes and remembering a cold rainy night in the winter of 2000.
A prominent developer by the name of James Duncan Davidson[1] was hacking his way through
Tomcat servlet container. As the time came to build the changes he carefully saved all
his files and ran <span class="RktSym">make</span><span class="RktMeta"></span>. Errors. Lots of errors. Something was wrong. After careful
examination James exclaimed: "Is my command not executing because I have a space in
front of my tab?!" Indeed, this was the problem. Again. James has had enough. He could
sense the full moon through the clouds and it made him adventurous. He created a fresh
Java project and quickly hacked together a simple but surprisingly useful utility. This
spark of genius used Java property files for information on how to build the project.
James could now write the equivalent of the makefile in a nice format without worrying
about the damned spaces ever again. His utility did all the hard work by interpreting
the property file and taking appropriate actions to build the project. It was neat.
Another Neat Tool. Ant.</p><p>After using Ant to build Tomcat for a few months it became clear that Java property
files are not sufficient to express complicated build instructions. Files needed to
be checked out, copied, compiled, sent to another machine, and unit tested. In case
of failure e-mails needed to be sent out to appropriate people. In case of success
"Bad to the Bone" needed to be played at the highest possible volume. At the end of
the track volume had to be restored to its original level. Yes, Java property files
didn&rsquo;t cut it anymore. James needed a more flexible solution. He didn&rsquo;t feel like
writing his own parser (especially since he wanted an industry standard solution).
XML seemed like a reasonable alternative. In a couple of days Ant was ported to XML.
It was the best thing since sliced bread.</p><p>So how does Ant work? It&rsquo;s pretty simple. It takes an XML file with specific build
instructions (you decide if they&rsquo;re data or code) and interprets them by running
specialized Java code for each XML element. It&rsquo;s actually much simpler than it sounds.
A simple XML instruction like the one below causes a Java class with an equivalent name
to be loaded and its code to be executed.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;copy</span><span class="hspace">&nbsp;</span><span class="RktMeta">todir="../new/dir"&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;fileset</span><span class="hspace">&nbsp;</span><span class="RktMeta">dir="src_dir"/&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/copy&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The snippet above copies a source directory to a destination directory. Ant locates a
"<span class="RktSym">copy</span><span class="RktMeta"></span>" task (a Java class, really), sets appropriate parameters (<span class="RktSym">todir</span><span class="RktMeta"></span>
and <span class="RktSym">fileset</span><span class="RktMeta"></span>) by calling appropriate Java methods and then executes
the task. Ant comes with a set of core tasks and anyone can extend it with
tasks of their own simply by writing Java classes that follow certain conventions.
Ant finds these classes and executes them whenever XML elements with appropriate
names are encountered. Pretty simple. Effectively Ant accomplishes what we
were talking about in the previous section: it acts as an interpreter for a
language that uses XML as its syntax by translating XML elements to appropriate
Java instructions. We could write an "<span class="RktSym">add</span><span class="RktMeta"></span>" task and have Ant execute it when it encounters
the XML snippet for addition presented in the previous section! Considering that Ant is
an extremely popular project, the ideas presented in the previous section start looking
more sane. After all, they&rsquo;re being used every day in what probably amounts to thousands
of companies!</p><p>So far I&rsquo;ve said nothing about why Ant actually goes through all the trouble of
interpreting XML. Don&rsquo;t try to look for the answer on its website either - you&rsquo;ll
find nothing of value. Nothing relevant to our discussion, anyway. Let&rsquo;s take
another step. It&rsquo;s time to find out why.</p><h4>2.4<tt>&nbsp;</tt><a name="(part._.Why_.X.M.L_)"></a>Why XML?</h4><p>Sometimes right decisions are made without full conscious understanding of all the
issues involved. I&rsquo;m not sure if James knew why he chose XML - it was likely a
subconscious decision. At the very least, the reasons I saw on Ant&rsquo;s website for
using XML are all the wrong reasons. It appears that the main concerns revolved
around portability and extensibility. I fail to see how XML helps advance these
goals in Ant&rsquo;s case. What is the advantage of using interpreted XML over simple
Java source code? Why not create a set of classes with a nice API for commonly
used tasks (copying directories, compiling, etc.) and using those directly from
Java source code? This would run on every platform that runs Java (which Ant requires
anyway), it&rsquo;s infinitely extensible, and it has the benefit of having a more pleasant,
familiar syntax. So why XML? Can we find a good reason for using it?</p><p>It turns out that we can (although as I mentioned earlier I&rsquo;m not sure if James was
consciously aware of it). XML has the property of being far more flexible in terms
of introduction of semantic constructs than Java could ever hope to be. Don&rsquo;t worry,
I&rsquo;m not falling into the trap of using big words to describe incomprehensible concepts.
This is actually a relatively simple idea, though it may take some effort to explain.
Buckle your seat-belt. We&rsquo;re about to make a giant leap towards achieving nirvana.</p><p>How can we represent &rsquo;<span class="RktSym">copy</span><span class="RktMeta"></span>&rsquo; example above in Java code? Here&rsquo;s one way to do it:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">CopyTask</span><span class="hspace">&nbsp;</span><span class="RktMeta">copy</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta">CopyTask();</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">Fileset</span><span class="hspace">&nbsp;</span><span class="RktMeta">fileset</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta">Fileset();</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">fileset.setDir("src_dir");</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">copy.setToDir("../new/dir");</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">copy.setFileset(fileset);</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">copy.execute();</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The code is almost the same, albeit a little longer than the original XML. So
what&rsquo;s different? The answer is that the XML snippet introduces a special semantic
construct for copying. If we could do it in Java it would look like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">copy("../new/dir")</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">fileset("src_dir");</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Can you see the difference? The code above (if it were possible in Java) is a
special operator for copying files - similar to a <span class="RktSym">for</span><span class="RktMeta"></span> loop or a new
<span class="RktSym">foreach</span><span class="RktMeta"></span> construct introduced in Java 5. If we had an automatic converter
from XML to Java it would likely produce the above gibberish. The reason for this is that Java&rsquo;s accepted
syntax tree grammar is fixed by the language specification - we have no way of
modifying it. We can add packages, classes, methods, but we cannot extend Java
to make addition of new operators possible. Yet we can do it to our heart&rsquo;s content
in XML - its syntax tree isn&rsquo;t restricted by anything except our interpreter! If
the idea is still unclear, consider introducing a special operator &rsquo;<span class="RktSym">unless</span><span class="RktMeta"></span>&rsquo; to Java:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">unless(someObject.canFly())</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">someObject.transportByGround();</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>In the previous two examples we extend the Java language to introduce an operator
for copying files and a conditional operator <span class="RktSym">unless</span><span class="RktMeta"></span>. We would do this by modifying
the abstract syntax tree grammar that Java compiler accepts. Naturally we cannot
do it with standard Java facilities, but we can easily do it in XML. Because our
XML interpreter parses the abstract syntax tree that results from it, we can extend
it to include any operator we like.</p><p>For complex operators this ability provides tremendous benefits. Can you imagine
writing special operators for checking out source code, compiling files, running
unit testing, sending email? Try to come up with some. If you&rsquo;re dealing with a
specialized problem (in our case it&rsquo;s building projects) these operators can do
wonders to decrease the amount of code you have to type and to increase clarity
and code reuse. Interpreted XML makes this extremely easy to accomplish because
it&rsquo;s a simple data file that stores hierarchical data. We do not have this option
in Java because it&rsquo;s hierarchical structure is fixed (as you will soon find out,
we do have this option in Lisp). Perhaps this is one of the reasons why Ant is
so successful?</p><p>I urge you to take a look at recent evolution of Java and C# (especially the
recently released specification for C# 3.0). The languages are being evolved by
abstracting away commonly used functionality and adding it in the form of operators.
New C# operators for built-in queries is one example. This is accomplished by
relatively traditional means: language creators modify the accepted abstract
syntax tree and add implementations of certain features. Imagine the possibilities
if the programmer could modify the abstract syntax tree himself! Whole new
sub-languages could be built for specialized domains (for example a language for
building projects, like Ant). Can you come up with other examples? Think about
these concepts for a bit, but don&rsquo;t worry about them too much. We&rsquo;ll come back
to these issues after introducing a few more ideas. By then things will be a
little more clear.</p><h4>2.5<tt>&nbsp;</tt><a name="(part._.Almost_.Lisp)"></a>Almost Lisp</h4><p>Let&rsquo;s forget about the operator business for the moment and try to expand our
horizons beyond the constraints of Ant&rsquo;s design. I mentioned earlier that Ant
can be extended by writing conventional Java classes. Ant interpreter then attempts
to match XML elements to appropriately named Java classes and if the match is
found the task is executed. An interesting question begs to be asked. Why not
extend Ant in Ant itself? After all, core tasks contain a lot of conventional
programming language constructs (&rsquo;if&rsquo; being a perfect example). If Ant provided
constructs to develop tasks in Ant itself we&rsquo;d reach a higher degree of portability.
We&rsquo;d be dependent on a core set of tasks (a standard library, if you will) and
we wouldn&rsquo;t care if Java runtime is present: the core set could be implemented
in anything. The rest of the tasks would be built on top of the core using Ant-XML
itself. Ant would then become a generic, extensible, XML-based programming
language. Consider the possibilities:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;task</span><span class="hspace">&nbsp;</span><span class="RktMeta">name="Test"&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;echo</span><span class="hspace">&nbsp;</span><span class="RktMeta">message="Hello</span><span class="hspace">&nbsp;</span><span class="RktMeta">World!"/&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/task&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;Test</span><span class="hspace">&nbsp;</span><span class="RktMeta">/&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>If ant supported the "<span class="RktSym">task</span><span class="RktMeta"></span>" construct, the example above would print "Hello
World!". In fact, we could write a "<span class="RktSym">task</span><span class="RktMeta"></span>" task in Java and make Ant able to extend
itself using Ant-XML! Ant would then be able to build more complicated primitives
on top of simple ones, just like any other programming language! This is an example
of "XML" based programming language we were talking about in the beginning of
this tutorial. Not very useful (can you tell why?) but pretty damn cool.</p><p>By the way, take a look at our &rsquo;<span class="RktSym">Test</span><span class="RktMeta"></span>&rsquo; task once again. Congratulations. You&rsquo;re
looking at Lisp code. What on Earth am I talking about? It doesn&rsquo;t look anything
like Lisp? Don&rsquo;t worry, we&rsquo;ll fix that in a bit. Confused? Good. Let&rsquo;s clear it all up!</p><h4>2.6<tt>&nbsp;</tt><a name="(part._.A_.Better_.X.M.L)"></a>A Better XML</h4><p>I mentioned in the previous section that self-extending Ant wouldn&rsquo;t be very
useful. The reason for that is XML&rsquo;s verbosity. It&rsquo;s not too bad for data files
but the moment you try writing reasonably complex code the amount of typing you
have to do quickly starts to get in the way and progresses to becoming unusable
for any real project. Have you ever tried writing Ant build scripts? I have, and
once they get complex enough having to do it in XML becomes really annoying.
Imagine having to type almost everything in Java twice because you have to close
every element. Wouldn&rsquo;t that drive you nuts?</p><p>The solution to this problem involves using a less verbose alternative to XML.
Remember, XML is just a format for representing hierarchical data. We don&rsquo;t have
to use XML&rsquo;s angle brackets to serialize trees. We could come up with many other
formats. One such format (incidentally, the one Lisp uses) is called an s-expression.
S-expressions accomplish the same goals as XML. They&rsquo;re just a lot less verbose,
which makes them much better suited for typing code. I will explain s-expressions
in a little while, but before I do I have to clear up a few things about XML.
Let&rsquo;s consider our XML example for copying files:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;copy</span><span class="hspace">&nbsp;</span><span class="RktMeta">todir="../new/dir"&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;fileset</span><span class="hspace">&nbsp;</span><span class="RktMeta">dir="src_dir"/&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/copy&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Think of what the parse tree of this snippet would look like in memory. We&rsquo;d have
a &rsquo;copy&rsquo; node that contains a fileset node. But what about attributes? How do they
fit into our picture? If you&rsquo;ve ever used XML to describe data and wondered whether
you should use an element or an attribute, you&rsquo;re not alone. Nobody can really
figure this out and doing it right tends to be black magic rather than science.
The reason for that is that attributes are really subsets of elements. Anything
attributes can do, elements can do as well. The reason attributes were introduced
is to curb XML&rsquo;s verbosity. Take a look at another version of our &rsquo;copy&rsquo; snippet:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;copy&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;todir&gt;../new/dir&lt;/todir&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;fileset&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;dir&gt;src_dir&lt;/dir&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;/fileset&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/copy&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The two snippets hold exactly the same information. However, we use attributes
to avoid typing the same thing more than once. Imagine if attributes weren&rsquo;t part
of XML specification. Writing anything in XML would drive us nuts!</p><p>Now that we got attributes out of the way, let&rsquo;s look at s-expressions. The reason
we took this detour is that s-expressions do not have attributes. Because they&rsquo;re
a lot less verbose, attributes are simply unnecessary. This is one thing we need
to keep in mind when transforming XML to s-expressions. Let&rsquo;s take a look at an
example. We could translate above snippet to s-expressions like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">copy</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">todir</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"../new/dir"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">fileset</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">dir</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"src_dir"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Take a good look at this representation. What&rsquo;s different? Angle brackets seem
to be replaced by parentheses. Instead of enclosing each element into a pair of
parentheses and then closing each element with a "(/element)" we simply skip the
second parenthesis in "(element" and proceed. The element is then closed like
this: ")". That&rsquo;s it! The translation is natural and very simple. It&rsquo;s also a lot
easier to type. Do parentheses blind first time users? Maybe, but now that we&rsquo;re
understand the reasoning behind them they&rsquo;re a lot easier to handle. At the very
least they&rsquo;re better than arthritis inducing verbosity of XML. After you get used
to s-expressions writing code in them is not only doable but very pleasant. And
they provide all the benefits of writing code in XML (many of which we&rsquo;re yet to
explore). Let&rsquo;s take a look at our &rsquo;task&rsquo; code in something that looks a lot
more like lisp:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">task</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">name</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Test"</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">echo</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">message</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Hello</span><span class="hspace">&nbsp;</span><span class="RktVal">World!"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Test</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>S-expressions are called lists in Lisp lingo. Consider our &rsquo;task&rsquo; element above.
If we rewrite it without a line break and with comas instead of spaces it&rsquo;s
starting to look surprisingly like a list of elements and other lists (the
formatting is added to make it easier to see nested lists):</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">task</span><span class="RktSym">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">name</span><span class="RktSym">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"test"</span><span class="RktPn">)</span><span class="RktSym">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">echo</span><span class="RktSym">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">message</span><span class="RktSym">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Hello</span><span class="hspace">&nbsp;</span><span class="RktVal">World!"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We could do the same with XML. Of course the line above isn&rsquo;t really a list,
it&rsquo;s a tree, just like its XML-alternative. Don&rsquo;t let references to lists confuse
you, it&rsquo;s just that lists that contain other lists and trees are effectively the
same thing. Lisp may stand for List Processing, but it&rsquo;s really tree processing
- no different than processing XML nodes.</p><p>Whew. After much rambling we finally got to something that looks like Lisp (and
is Lisp, really). By now the mysterious Lisp parentheses as well as some claims
made by Lisp advocates should become more clear. But we still have a lot of ground
to cover. Ready? Let&rsquo;s move on!</p><h4>2.7<tt>&nbsp;</tt><a name="(part._.C_.Macros_.Reloaded)"></a>C Macros Reloaded</h4><p>By now you must be tired of all the XML talk. I&rsquo;m tired of it as well. It&rsquo;s time
to take a break from all the trees, s-expressions, and Ant business. Instead, let&rsquo;s
go back to every programmer&rsquo;s roots. It&rsquo;s time to talk about C preprocessor. What&rsquo;s
C got to do with anything, I hear you ask? Well, we now know enough to get into
metaprogramming and discuss code that writes other code. Understanding this tends
to be hard since all tutorials discuss it in terms of languages that you don&rsquo;t
know. But there is nothing hard about the concept. I believe that a metaprogramming
discussion based on C will make the whole thing much easier to understand. So,
let&rsquo;s see (pun intended).</p><p>Why would anyone want to write a program that writes programs? How can we use
something like this in the real world? What on Earth is metaprogramming, anyway?
You already know all the answers, you just don&rsquo;t know it yet. In order to unlock
the hidden vault of divine knowledge let&rsquo;s consider a rather mundane task of simple
database access from code. We&rsquo;ve all been there. Writing SQL queries all over the
code to modify data within tables turns into repetitive hell soon enough. Even
with the new C# 3.0 LINQ stuff this is a huge pain. Writing a full SQL query
(albeit with a nice built in syntax) to get someone&rsquo;s name or to modify someone&rsquo;s
address isn&rsquo;t exactly a programmer&rsquo;s idea of comfort. What do we do to solve these
problems? Enter data access layers.</p><p>The idea is simple enough. You abstract database access (at least trivial queries,
anyway) by creating a set of classes that mirror the tables in the database and
use accessor methods to execute actual queries. This simplifies development
tremendously - instead of writing SQL queries we make simple method calls (or
property assignments, depending on your language of choice). Anyone who has ever
used even the simplest of data access layers knows how much time it can save. Of
course anyone who has ever written one knows how much time it can kill - writing
a set of classes that mirror tables and convert accessors to SQL queries takes a
considerable chunk of time. This seems especially silly since most of the work is
manual: once you figure out the design and develop a template for your typical
data access class you don&rsquo;t need to do any thinking. You just write code based
on the same template over and over and over and over again. Many people figured
out that there is a better way - there are plenty of tools that connect to the
database, grab the schema, and write code for you based on a predefined (or a
custom) template.</p><p>Anyone who has ever used such a tool knows what an amazing time saver it can be.
In a few clicks you connect the tool to the database, get it to generate the data
access layer source code, add the files to your project and voil&#224; - ten minutes
worth of work do a better job than hundreds of man-hours that were required previously.
What happens if your database schema changes? Well, you just have to go through
this short process again. Of course some of the best tools let you automate this
- you simply add them as a part of your build step and every time you compile
your project everything is done for you automatically. This is perfect! You barely
have to do anything at all. If the schema ever changes your data access layer code
updates automatically at compile time and any obsolete access in your code will
result in compiler errors!</p><p>Data access layers are one good example, but there are plenty of others. From
boilerplate GUI code, to web code, to COM and CORBA stubs, to MFC and ATL, - there
are plenty of examples where the same code is written over and over again. Since
writing this code is a task that can be automated completely and a programmer&rsquo;s
time is far more expensive than CPU time, plenty of tools have been created that
generate this boilerplate code automatically. What are these tools, exactly? Well,
they are programs that write programs. They perform a simple task that has a
mysterious name of metaprogramming. That&rsquo;s all there is to it.</p><p>We could create and use such tools in millions of scenarios but more often than
not we don&rsquo;t. What it boils down to is a subconscious calculation - is it worth
it for me to create a separate project, write a whole tool to generate something,
and then use it, if I only have to write these very similar pieces about seven
times? Of course not. Data access layers and COM stubs are written hundreds,
thousands of times. This is why there are tools for them. For similar pieces of
code that repeat only a few times, or even a few dozen times, writing code
generation tools isn&rsquo;t even considered. The trouble to create such a tool more
often than not far outweighs the benefit of using one. If only creating such tools
was much easier, we could use them more often, and perhaps save many hours of
our time. Let&rsquo;s see if we can accomplish this in a reasonable manner.</p><p>Surprisingly C preprocessor comes to the rescue. We&rsquo;ve all used it in C and C++.
On occasion we all wish Java had it. We use it to execute simple instructions at
compile time to make small changes to our code (like selectively removing debug
statements). Let&rsquo;s look at a quick example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">#define</span><span class="hspace">&nbsp;</span><span class="RktMeta">triple(X)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">X</span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">X</span><span class="hspace">&nbsp;</span><span class="RktMeta">+</span><span class="hspace">&nbsp;</span><span class="RktMeta">X</span><span class="RktMeta"></span></td></tr></table></blockquote><p>What does this line do? It&rsquo;s a simple instruction written in the preprocessor
language that instructs it to replace all instances of <span class="RktSym">triple</span><span class="RktPn">(</span><span class="RktSym">X</span><span class="RktPn">)</span><span class="RktMeta"></span> with
<span class="RktSym">X</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">X</span><span class="RktMeta"></span>. For example all instances of &rsquo;<span class="RktSym">triple</span><span class="RktPn">(</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span>&rsquo; will be
replaced with &rsquo;<span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span>&rsquo; and the resulting code will be compiled by the
C compiler. We&rsquo;re really doing a very primitive version of code generation here.
If only C preprocessor was a little more powerful and included ways to connect
to the database and a few more simple constructs, we could use it to develop our
data access layer right there, from within our program! Consider the following
example that uses an imaginary extension of the C preprocessor:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">#get-db-schema("127.0.0.1,</span><span class="hspace">&nbsp;</span><span class="RktMeta">un,</span><span class="hspace">&nbsp;</span><span class="RktMeta">pwd");</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">#iterate-through-tables</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">#for-each-table</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta">#table-name</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">};</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">#end-for-each</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We&rsquo;ve just connected to the database schema, iterated through all the tables,
and created an empty class for each. All in a couple of lines right within our
source code! Now every time we recompile the file where above code appears we&rsquo;ll
get a freshly built set of classes that automatically update based on the schema.
With a little imagination you can see how we could build a full data access layer
straight from within our program, without the use of any external tools! Of course
this has a certain disadvantage (aside from the fact that such an advanced version
of C preprocessor doesn&rsquo;t exist) - we&rsquo;d have to learn a whole new "compile-time
language" to do this sort of work. For complex code generation this language
would have to be very complex as well, it would have to support many libraries
and language constructs. For example, if our generated code depended on some
file located at some ftp server the preprocessor would have to be able to connect
to ftp. It&rsquo;s a shame to create and learn a new language just to do this. Especially
since there are so many nice languages already out there. Of course if we add a
little creativity we can easily avoid this pitfall.</p><p>Why not replace the preprocessor language with C/C++ itself? We&rsquo;d have full
power of the language at compile time and we&rsquo;d only need to learn a few simple
directives to differentiate between compile time and runtime code!</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;%</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">cout</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">"Enter</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">number:</span><span class="hspace">&nbsp;</span><span class="RktMeta">";</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">cin</span><span class="hspace">&nbsp;</span><span class="RktMeta">&gt;&gt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">n;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">%&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">for(int</span><span class="hspace">&nbsp;</span><span class="RktMeta">i</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">0;</span><span class="hspace">&nbsp;</span><span class="RktMeta">i</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;%=</span><span class="hspace">&nbsp;</span><span class="RktMeta">n</span><span class="hspace">&nbsp;</span><span class="RktMeta">%&gt;;</span><span class="hspace">&nbsp;</span><span class="RktMeta">i++)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">cout</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">"hello"</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">endl;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Can you see what happens here? Everything that&rsquo;s between &lt;% and %&gt; tags runs
when the program is compiled. Anything outside of these tags is normal code.
In the example above you&rsquo;d start compiling your program in the development
environment. The code between the tags would be compiled and then ran. You&rsquo;d
get a prompt to enter a number. You&rsquo;d enter one and it would be placed inside
the for loop. The for loop would then be compiled as usual and you&rsquo;d be able
to execute it. For example, if you&rsquo;d enter 5 during the compilation of your
program, the resulting code would look like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">for(int</span><span class="hspace">&nbsp;</span><span class="RktMeta">i</span><span class="hspace">&nbsp;</span><span class="RktMeta">=</span><span class="hspace">&nbsp;</span><span class="RktMeta">0;</span><span class="hspace">&nbsp;</span><span class="RktMeta">i</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">5;</span><span class="hspace">&nbsp;</span><span class="RktMeta">i++)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">cout</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">"hello"</span><span class="hspace">&nbsp;</span><span class="RktMeta">&lt;&lt;</span><span class="hspace">&nbsp;</span><span class="RktMeta">endl;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Simple and effective. No need for a special preprocessor language. We get full
power of our host language (in this case C/C++) at compile time. We could easily
connect to a database and generate our data access layer source code at compile
time in the same way JSP or ASP generate HTML! Creating such tools would also
be tremendously quick and simple. We&rsquo;d never have to create new projects with
specialized GUIs. We could inline our tools right into our programs. We wouldn&rsquo;t
have to worry about whether writing such tools is worth it because writing them
would be so fast - we could save tremendous amounts of time by creating simple
bits of code that do mundane code generation for us!</p><h4>2.8<tt>&nbsp;</tt><a name="(part._.Hello__.Lisp_)"></a>Hello, Lisp!</h4><p>Everything we&rsquo;ve learned about Lisp so far can be summarized by a single
statement: Lisp is executable XML with a friendlier syntax. We haven&rsquo;t said a
single word about how Lisp actually operates. It&rsquo;s time to fill this gap[2].</p><p>Lisp has a number of built in data types. Integers and strings, for example,
aren&rsquo;t much different from what you&rsquo;re used to. The meaning of 71 or "hello"
is roughly the same in Lisp as in C++ or Java. What is of more interest to us
are symbols, lists, and functions. I will spend the rest of this section describing
these data types as well as how a Lisp environment compiles and executes the
source code you type into it (this is called evaluation in Lisp lingo). Getting
through this section in one piece is important for understanding true potential
of Lisp&rsquo;s metaprogramming, the unity of code and data, and the notion of domain
specific languages. Don&rsquo;t think of this section as a chore though, I&rsquo;ll try to
make it fun and accessible. Hopefully you can pick up a few interesting ideas
on the way. Ok. Let&rsquo;s start with Lisp&rsquo;s symbols.</p><p>A symbol in Lisp is roughly equivalent to C++ or Java&rsquo;s notion of an identifier.
It&rsquo;s a name you can use to access a variable (like currentTime, arrayCount, n, etc.)
The difference is that a symbol in Lisp is a lot more liberal than its mainstream
identifier alternative. In C++ or Java you&rsquo;re limited to alphanumeric characters
and an underscore. In Lisp, you are not. For example + is a valid symbol. So is
-, =, hello-world, hello+world, *, etc. (you can find the exact definition of
valid Lisp symbols online). You can assign to these symbols any data-type you
like. Let&rsquo;s ignore Lisp syntax and use pseudo-code for now. Assume that a function
set assigns some value to a symbol (like = does in Java or C++). The following
are all valid examples:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">set(test,</span><span class="hspace">&nbsp;</span><span class="RktMeta">5)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'test'</span><span class="hspace">&nbsp;</span><span class="RktMeta">will</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">an</span><span class="hspace">&nbsp;</span><span class="RktMeta">integer</span><span class="hspace">&nbsp;</span><span class="RktMeta">5</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(=,</span><span class="hspace">&nbsp;</span><span class="RktMeta">5)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'='</span><span class="hspace">&nbsp;</span><span class="RktMeta">will</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">an</span><span class="hspace">&nbsp;</span><span class="RktMeta">integer</span><span class="hspace">&nbsp;</span><span class="RktMeta">5</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(test,</span><span class="hspace">&nbsp;</span><span class="RktMeta">"hello")</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'test'</span><span class="hspace">&nbsp;</span><span class="RktMeta">will</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">"hello"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(test,</span><span class="hspace">&nbsp;</span><span class="RktMeta">=)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">at</span><span class="hspace">&nbsp;</span><span class="RktMeta">this</span><span class="hspace">&nbsp;</span><span class="RktMeta">point</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'='</span><span class="hspace">&nbsp;</span><span class="RktMeta">is</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">5</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">therefore</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'test'</span><span class="hspace">&nbsp;</span><span class="RktMeta">will</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">5</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(*,</span><span class="hspace">&nbsp;</span><span class="RktMeta">"hello")</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'*'</span><span class="hspace">&nbsp;</span><span class="RktMeta">will</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">string</span><span class="hspace">&nbsp;</span><span class="RktMeta">"hello"</span><span class="RktMeta"></span></td></tr></table></blockquote><p>At this point something must smell wrong. If we can assign strings and integers
to symbols like *, how does Lisp do multiplication? After all, * means multiply,
right? The answer is pretty simple. Functions in Lisp aren&rsquo;t special. There is a
data-type, function, just like integer and string, that you assign to symbols. A
multiplication function is built into Lisp and is assigned to a symbol *. You
can reassign a different value to * and you&rsquo;d lose the multiplication function.
Or you can store the value of the function in some other variable. Again, using
pseudo-code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">*(3,</span><span class="hspace">&nbsp;</span><span class="RktMeta">4)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiplies</span><span class="hspace">&nbsp;</span><span class="RktMeta">3</span><span class="hspace">&nbsp;</span><span class="RktMeta">by</span><span class="hspace">&nbsp;</span><span class="RktMeta">4,</span><span class="hspace">&nbsp;</span><span class="RktMeta">resulting</span><span class="hspace">&nbsp;</span><span class="RktMeta">in</span><span class="hspace">&nbsp;</span><span class="RktMeta">12</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(temp,</span><span class="hspace">&nbsp;</span><span class="RktMeta">*)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'*'</span><span class="hspace">&nbsp;</span><span class="RktMeta">is</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiply</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">so</span><span class="hspace">&nbsp;</span><span class="RktMeta">temp</span><span class="hspace">&nbsp;</span><span class="RktMeta">will</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiply</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(*,</span><span class="hspace">&nbsp;</span><span class="RktMeta">3)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">sets</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'*'</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">3</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">*(3,</span><span class="hspace">&nbsp;</span><span class="RktMeta">4)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">error,</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'*'</span><span class="hspace">&nbsp;</span><span class="RktMeta">no</span><span class="hspace">&nbsp;</span><span class="RktMeta">longer</span><span class="hspace">&nbsp;</span><span class="RktMeta">equals</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">it's</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">3</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">temp(3,</span><span class="hspace">&nbsp;</span><span class="RktMeta">4)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">temp</span><span class="hspace">&nbsp;</span><span class="RktMeta">equals</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiply</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">so</span><span class="hspace">&nbsp;</span><span class="RktMeta">Lisp</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiplies</span><span class="hspace">&nbsp;</span><span class="RktMeta">3</span><span class="hspace">&nbsp;</span><span class="RktMeta">by</span><span class="hspace">&nbsp;</span><span class="RktMeta">4</span><span class="hspace">&nbsp;</span><span class="RktMeta">resulting</span><span class="hspace">&nbsp;</span><span class="RktMeta">in</span><span class="hspace">&nbsp;</span><span class="RktMeta">12</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">set(*,</span><span class="hspace">&nbsp;</span><span class="RktMeta">temp)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'*'</span><span class="hspace">&nbsp;</span><span class="RktMeta">equals</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiply</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="hspace">&nbsp;</span><span class="RktMeta">again</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">*(3,</span><span class="hspace">&nbsp;</span><span class="RktMeta">4)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">multiplies</span><span class="hspace">&nbsp;</span><span class="RktMeta">3</span><span class="hspace">&nbsp;</span><span class="RktMeta">by</span><span class="hspace">&nbsp;</span><span class="RktMeta">4,</span><span class="hspace">&nbsp;</span><span class="RktMeta">resulting</span><span class="hspace">&nbsp;</span><span class="RktMeta">in</span><span class="hspace">&nbsp;</span><span class="RktMeta">12</span><span class="RktMeta"></span></td></tr></table></blockquote><p>You can even do wacky stuff like reassigning plus to minus:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">set(+,</span><span class="hspace">&nbsp;</span><span class="RktMeta">-)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">value</span><span class="hspace">&nbsp;</span><span class="RktMeta">of</span><span class="hspace">&nbsp;</span><span class="RktMeta">'-'</span><span class="hspace">&nbsp;</span><span class="RktMeta">is</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">built</span><span class="hspace">&nbsp;</span><span class="RktMeta">in</span><span class="hspace">&nbsp;</span><span class="RktMeta">minus</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">so</span><span class="hspace">&nbsp;</span><span class="RktMeta">now</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'+'</span><span class="hspace">&nbsp;</span><span class="RktMeta">equals</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">minus</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">+(5,</span><span class="hspace">&nbsp;</span><span class="RktMeta">4)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">since</span><span class="hspace">&nbsp;</span><span class="RktMeta">symbol</span><span class="hspace">&nbsp;</span><span class="RktMeta">'+'</span><span class="hspace">&nbsp;</span><span class="RktMeta">is</span><span class="hspace">&nbsp;</span><span class="RktMeta">equal</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">minus</span><span class="hspace">&nbsp;</span><span class="RktMeta">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">this</span><span class="hspace">&nbsp;</span><span class="RktMeta">results</span><span class="hspace">&nbsp;</span><span class="RktMeta">in</span><span class="hspace">&nbsp;</span><span class="RktMeta">1</span><span class="RktMeta"></span></td></tr></table></blockquote><p>I&rsquo;ve used functions quite liberally in these examples but I didn&rsquo;t describe them
yet. A function in Lisp is just a data-type like an integer, a string, or a symbol.
A function doesn&rsquo;t have a notion of a name like in Java or C++. Instead, it stands
on its own. Effectively it is a pointer to a block of code along with some
information (like a number of parameters it accepts). You only give the function
a name by assigning it to a symbol, just like you assign an integer or a string.
You can create a function by using a built in function for creating functions,
assigned to a symbol &rsquo;fn&rsquo;. Using pseudo-code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">fn</span><span class="hspace">&nbsp;</span><span class="RktMeta">[a]</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta">*(a,</span><span class="hspace">&nbsp;</span><span class="RktMeta">2);</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This returns a function that takes a single parameter named &rsquo;a&rsquo; and doubles it.
Note that the function has no name but you can assign it to a symbol:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">set(times-two,</span><span class="hspace">&nbsp;</span><span class="RktMeta">fn</span><span class="hspace">&nbsp;</span><span class="RktMeta">[a]</span><span class="hspace">&nbsp;</span><span class="RktMeta">{</span><span class="hspace">&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta">*(a,</span><span class="hspace">&nbsp;</span><span class="RktMeta">2);</span><span class="hspace">&nbsp;</span><span class="RktMeta">})</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We can now call this function:</p><p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">times-two(5)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">//</span><span class="hspace">&nbsp;</span><span class="RktMeta">returns</span><span class="hspace">&nbsp;</span><span class="RktMeta">10</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">Now that we went over symbols and functions, what about lists? Well, you already
know a lot about them. Lists are simply pieces of XML written in s-expression
form. A list is specified by parentheses and contains Lisp data-types (including
other lists) separated by a space. For example (this is real Lisp, note that we
use semicolons for comments now):</div></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">empty</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">with</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">single</span><span class="hspace">&nbsp;</span><span class="RktCmt">element,</span><span class="hspace">&nbsp;</span><span class="RktCmt">1</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"test"</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">with</span><span class="hspace">&nbsp;</span><span class="RktCmt">two</span><span class="hspace">&nbsp;</span><span class="RktCmt">elements</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">integer</span><span class="hspace">&nbsp;</span><span class="RktCmt">1</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">string</span><span class="hspace">&nbsp;</span><span class="RktCmt">"test"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"hello"</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">with</span><span class="hspace">&nbsp;</span><span class="RktCmt">two</span><span class="hspace">&nbsp;</span><span class="RktCmt">elements</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">test</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">string</span><span class="hspace">&nbsp;</span><span class="RktCmt">"hello"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"hello"</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">with</span><span class="hspace">&nbsp;</span><span class="RktCmt">three</span><span class="hspace">&nbsp;</span><span class="RktCmt">elements,</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">test</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">two</span><span class="hspace">&nbsp;</span><span class="RktCmt">integers</span><span class="hspace">&nbsp;</span><span class="RktCmt">1</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">2</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">string</span><span class="hspace">&nbsp;</span><span class="RktCmt">"hello"</span><span class="RktMeta"></span></td></tr></table></blockquote><p>When a Lisp system encounters lists in the source code it acts exactly like Ant
does when it encounters XML - it attempts to execute them. In fact, Lisp source
code is only specified using lists, just like Ant source code is only specified
using XML. Lisp executes lists in the following manner. The first element of the
list is treated as the name of a function. The rest of the elements are treated
as functions parameters. If one of the parameters is another list it is executed
using the same principles and the result is passed as a parameter to the original
function. That&rsquo;s it. We can write real code now:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">equivalent</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">pseudo-code</span><span class="hspace">&nbsp;</span><span class="RktCmt">*(3,</span><span class="hspace">&nbsp;</span><span class="RktCmt">4).</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">'*'</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">3</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">4</span><span class="hspace">&nbsp;</span><span class="RktCmt">are</span><span class="hspace">&nbsp;</span><span class="RktCmt">its</span><span class="hspace">&nbsp;</span><span class="RktCmt">parameters.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">12.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">times-two</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">10</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">error:</span><span class="hspace">&nbsp;</span><span class="RktCmt">3</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">not</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">times-two</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">error,</span><span class="hspace">&nbsp;</span><span class="RktCmt">times-two</span><span class="hspace">&nbsp;</span><span class="RktCmt">expects</span><span class="hspace">&nbsp;</span><span class="RktCmt">one</span><span class="hspace">&nbsp;</span><span class="RktCmt">parameter</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">times-two</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">error,</span><span class="hspace">&nbsp;</span><span class="RktCmt">times-two</span><span class="hspace">&nbsp;</span><span class="RktCmt">expects</span><span class="hspace">&nbsp;</span><span class="RktCmt">one</span><span class="hspace">&nbsp;</span><span class="RktCmt">parameter</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">sets</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">'+'</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">be</span><span class="hspace">&nbsp;</span><span class="RktCmt">equal</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">whatever</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">'-'</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">equals</span><span class="hspace">&nbsp;</span><span class="RktCmt">to,</span><span class="hspace">&nbsp;</span><span class="RktCmt">which</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">minus</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">1</span><span class="hspace">&nbsp;</span><span class="RktCmt">since</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">'+'</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">now</span><span class="hspace">&nbsp;</span><span class="RktCmt">equal</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">minus</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">multiplies</span><span class="hspace">&nbsp;</span><span class="RktCmt">3</span><span class="hspace">&nbsp;</span><span class="RktCmt">by</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">second</span><span class="hspace">&nbsp;</span><span class="RktCmt">parameter</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(which</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="hspace">&nbsp;</span><span class="RktCmt">call</span><span class="hspace">&nbsp;</span><span class="RktCmt">that</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">4).</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">12.</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Note that so far every list we&rsquo;ve specified was treated by a Lisp system as code.
But how can we treat a list as data? Again, imagine an Ant task that accepts XML
as one of its parameters. In Lisp we do this using a quote operator &rsquo; like so:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">set</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">test</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">equal</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">two</span><span class="hspace">&nbsp;</span><span class="RktCmt">integers,</span><span class="hspace">&nbsp;</span><span class="RktCmt">1</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">2</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">error,</span><span class="hspace">&nbsp;</span><span class="RktCmt">1</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">not</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">function</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">test</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">sets</span><span class="hspace">&nbsp;</span><span class="RktCmt">test</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">three</span><span class="hspace">&nbsp;</span><span class="RktCmt">elements,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">*,</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">integer</span><span class="hspace">&nbsp;</span><span class="RktCmt">3,</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">integer</span><span class="hspace">&nbsp;</span><span class="RktCmt">4</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We can use a built in function head to return the first element of the list, and
a built in function tail to return the rest of the list&rsquo;s elements:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">head</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">'*'</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">tail</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">(3</span><span class="hspace">&nbsp;</span><span class="RktCmt">4)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">head</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">tail</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">(tail</span><span class="hspace">&nbsp;</span><span class="RktCmt">'(*</span><span class="hspace">&nbsp;</span><span class="RktCmt">3</span><span class="hspace">&nbsp;</span><span class="RktCmt">4))</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">(3</span><span class="hspace">&nbsp;</span><span class="RktCmt">4)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">and</span><span class="hspace">&nbsp;</span><span class="RktCmt">(head</span><span class="hspace">&nbsp;</span><span class="RktCmt">'(3</span><span class="hspace">&nbsp;</span><span class="RktCmt">4))</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">3.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">head</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">test</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">test</span><span class="hspace">&nbsp;</span><span class="RktCmt">was</span><span class="hspace">&nbsp;</span><span class="RktCmt">set</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">list</span><span class="hspace">&nbsp;</span><span class="RktCmt">in</span><span class="hspace">&nbsp;</span><span class="RktCmt">previous</span><span class="hspace">&nbsp;</span><span class="RktCmt">example</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">returns</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">'*'</span><span class="RktMeta"></span></td></tr></table></blockquote><p>You can think of built in Lisp functions as you think of Ant tasks. The difference
is that we don&rsquo;t have to extend Lisp in another language (although we can), we
can extend it in Lisp itself as we did with the times-two example. Lisp comes
with a very compact set of built in functions - the necessary minimum. The rest
of the language is implemented as a standard library in Lisp itself.</p><h4>2.9<tt>&nbsp;</tt><a name="(part._.Lisp_.Macros)"></a>Lisp Macros</h4><p>So far we&rsquo;ve looked at metaprogramming in terms of a simple templating engine
similar to JSP. We&rsquo;ve done code generation using simple string manipulations.
This is generally how most code generation tools go about doing this task. But
we can do much better. To get on the right track, let&rsquo;s start off with a question.
How would we write a tool that automatically generates Ant build scripts by
looking at source files in the directory structure?</p><p>We could take the easy way out and generate Ant XML by manipulating strings. Of
course a much more abstract, expressive and extensible way is to work with XML
processing libraries to generate XML nodes directly in memory. The nodes can then
be serialized to strings automatically. Furthermore, our tool would be able to
analyze and transform existing Ant build scripts by loading them and dealing with
the XML nodes directly. We would abstract ourselves from strings and deal with
higher level concepts which let us get the job done faster and easier.</p><p>Of course we could write Ant tasks that allow dealing with XML transformations
and write our generation tool in Ant itself. Or we could just use Lisp. As we
saw earlier, a list is a built in Lisp data structure and Lisp has a number of
facilities for processing lists quickly and effectively (head and tail being the
simplest ones). Additionally Lisp has no semantic constraints - you can have your
code (and data) have any structure you want.</p><p>Metaprogramming in Lisp is done using a construct called a "macro". Let&rsquo;s try to
develop a set of macros that transform data like, say, a to-do list (surprised?),
into a language for dealing with to-do lists.</p><p>Let&rsquo;s recall our to-do list example. The XML looks like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;todo</span><span class="hspace">&nbsp;</span><span class="RktMeta">name="housework"&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;item</span><span class="hspace">&nbsp;</span><span class="RktMeta">priority="high"&gt;Clean</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">house.&lt;/item&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;item</span><span class="hspace">&nbsp;</span><span class="RktMeta">priority="medium"&gt;Wash</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">dishes.&lt;/item&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">&lt;item</span><span class="hspace">&nbsp;</span><span class="RktMeta">priority="medium"&gt;Buy</span><span class="hspace">&nbsp;</span><span class="RktMeta">more</span><span class="hspace">&nbsp;</span><span class="RktMeta">soap.&lt;/item&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&lt;/todo&gt;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The corresponding s-expression version looks like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">todo</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"housework"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">item</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">priority</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">high</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Clean</span><span class="hspace">&nbsp;</span><span class="RktVal">the</span><span class="hspace">&nbsp;</span><span class="RktVal">house."</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">item</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">priority</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">medium</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Wash</span><span class="hspace">&nbsp;</span><span class="RktVal">the</span><span class="hspace">&nbsp;</span><span class="RktVal">dishes."</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">item</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">priority</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">medium</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Buy</span><span class="hspace">&nbsp;</span><span class="RktVal">more</span><span class="hspace">&nbsp;</span><span class="RktVal">soap."</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Suppose we&rsquo;re writing a to-do manager application. We keep our to-do items
serialized in a set of files and when the program starts up we want to read them
and display them to the user. How would we do this with XML and some other language
(say, Java)? We&rsquo;d parse our XML files with the to-do lists using some XML parser,
write the code that walks the XML tree and converts it to a Java data structure
(because frankly, processing DOM in Java is a pain in the neck), and then use this
data structure to display the data. Now, how would we do the same thing in Lisp?</p><p>If we were to adopt the same approach we&rsquo;d parse the files using Lisp libraries
responsible for parsing XML. The XML would then be presented to us as a Lisp list
(an s-expression) and we&rsquo;d walk the list and present relevant data to the user.
Of course if we used Lisp it would make sense to persist the data as s-expressions
directly as there&rsquo;s no reason to do an XML conversion. We wouldn&rsquo;t need special parsing
libraries since data persisted as a set of s-expressions is valid Lisp and we
could use Lisp compiler to parse it and store it in memory as a Lisp list. Note
that Lisp compiler (much like .NET compiler) is available to a Lisp program at runtime.</p><p>But we can do better. Instead of writing code to walk the s-expression that stores
our data we could write a macro that allows us to treat data as code! How do macros
work? Pretty simple, really. Recall that a Lisp function is called like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">function-name</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">arg1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">arg2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">arg3</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Where each argument is a valid Lisp expression that&rsquo;s evaluated and passed to the
function. For example if we replace arg1 above with (+ 4 5), it will be evaluated
and 9 would be passed to the function. A macro works the same way as a function,
except its arguments are not evaluated.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">macro-name</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>In this case, (+ 4 5) is not evaluated and is passed to the macro as a list. The
macro is then free to do what it likes with it, including evaluating it. The return
value of a macro is a Lisp list that&rsquo;s treated as code. The original place with the
macro is replaced with this code. For example, we could define a macro plus that
takes two arguments and puts in the code that adds them.</p><p>What does it have to do with metaprogramming and our to-do list problem? Well,
for one, macros are little bits of code that generate code using a list abstraction.
Also, we could create macros named to-do and item that replace our data with
whatever code we like, for instance code that displays the item to the user.</p><p>What benefits does this approach offer? We don&rsquo;t have to walk the list. The
compiler will do it for us and will invoke appropriate macros. All we need to
do is create the macros that convert our data to appropriate code!</p><p>For example, a macro similar to our triple C macro we showed earlier looks like this:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">defmacro</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">triple</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">~x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">~x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">~x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The quote prevents evaluation while the tilde allows it. Now every time triple
is encountered in lisp code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">triple</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>it is replaced with the following code:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We can create macros for our to-do list items that will get called by lisp
compiler and will transform the to-do list into code. Now our to-do list will
be treated as code and will be executed. Suppose all we want to do is print it
to standard output for the user to read:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">defmacro</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">item</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">priority</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">note</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktSym">block</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">print</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">stdout</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tab</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Priority:</span><span class="hspace">&nbsp;</span><span class="RktVal">"</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">~</span><span class="RktPn">(</span><span class="RktSym">head</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">tail</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">priority</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">endl</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">print</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">stdout</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">tab</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"Note:</span><span class="hspace">&nbsp;</span><span class="RktVal">"</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">~note</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">endl</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">endl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We&rsquo;ve just created a very small and limited language for managing to-do lists
embedded in Lisp. Such languages are very specific to a particular problem
domain and are often referred to as domain specific languages or DSLs.</p><h4>2.10<tt>&nbsp;</tt><a name="(part._.Domain_.Specific_.Languages)"></a>Domain Specific Languages</h4><p>In this article we&rsquo;ve already encountered two domain specific languages: Ant
(specific to dealing with project builds) and our unnamed mini-language for
dealing with to-do lists. The difference is that Ant was written from scratch
using XML, an XML parser, and Java while our language is embedded into Lisp
and is easily created within a couple of minutes.</p><p>We&rsquo;ve already discussed the benefits of DSLs, mainly why Ant is using XML, not
Java source code. Lisp lets us create as many DSLs as we need for our problem.
We can create domain specific languages for creating web applications, writing
massively multiplayer games, doing fixed income trading, solving the protein
folding problem, dealing with transactions, etc. We can layer these languages
on top of each other and create a language for writing web-based trading
applications by taking advantage of our web application language and bond trading
language. Every day we&rsquo;d reap the benefits of this approach, much like we reap
the benefits of Ant.</p><p>Using DSLs to solve problems results in much more compact, maintainable, flexible
programs. In a way we create them in Java by creating classes that help us
solve the problem. The difference is that Lisp allows us to take this abstraction
to the next level: we&rsquo;re not limited by Java&rsquo;s parser. Think of writing build
scripts in Java itself using some supporting library. Compare it to using Ant.
Now apply this same comparison to every single problem you&rsquo;ve ever worked on
and you&rsquo;ll begin to glimpse a small share of the benefits offered by Lisp.</p><h4>2.11<tt>&nbsp;</tt><a name="(part._.What_s_next_)"></a>What&rsquo;s next?</h4><p>Learning Lisp is an uphill battle. Even though in Computer Science terms Lisp
is an ancient language, few people to date figured out how to teach it well
enough to make it accessible. Despite great efforts by many Lisp advocates,
learning Lisp today is still hard. The good news is that this won&rsquo;t remain
the case forever since the amount of Lisp-related resources is rapidly increasing.
Time is on Lisp&rsquo;s side.</p><p>Lisp is a way to escape mediocrity and to get ahead of the pack. Learning Lisp
means you can get a better job today, because you can impress any reasonably
intelligent interviewer with fresh insight into most aspects of software
engineering. It also means you&rsquo;re likely to get fired tomorrow because everyone
is tired of you constantly mentioning how much better the company could be
doing if only its software was written in Lisp. Is it worth the effort? Everyone
who has ever learned Lisp says yes. The choice, of course, remains yours.</p><h4>2.12<tt>&nbsp;</tt><a name="(part._.Comments_)"></a>Comments?</h4><p>Whew. That&rsquo;s enough. I&rsquo;ve been writing this article, on and off, for months.
If you find it interesting, have any questions, comments, or suggestions, please
drop a note at <a href="#">coffeemug@gmail.com</a>. I&rsquo;ll be glad to hear your feedback.</p><p>[1] I have never met James, nor does he know about my existence. The story is
entirely fictional and is based on a few postings about Ant&rsquo;s history I found
on the internet.</p><p>[2] Lisp has many different dialects (the most popular of which are Common Lisp
and Scheme). Each dialect deals with intricate details differently yet shares
the same set of basic principles. Since the goal of this article is to give you
an understanding of Lisp&rsquo;s principles I will use Blaise for examples (which at
the time of this writing is vaporware). With some minor modifications these
examples can be translated to other Lisp dialects.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="The_Hy_Programming_Language.html" title="backward to &quot;1 The Hy Programming Language&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;蚯鲇蜍的博客&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="The_Nature_of_Lisp__Cursor_Translated.html" title="forward to &quot;3 The Nature of Lisp, Cursor Translated&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>