#lang scribble/manual

@(require "util.rkt")

@title{The Nature of Lisp, Cursor Translated}

@smaller{2006年5月8日}

@centered{本文转自@hyperlink["#" "defmacro.org"], 作者Slava Akhmechet, 译者Cursor}

@section{简介}

当我第一次在网络的各个角落偶然发现Lisp时，我已经是一位经验丰富的程序员了。那时，我已经掌握了众多编程语言，为自己能熟练使用众多编程语言（如C++、Java、C#等）而感到自豪，并认为自己已经了解了所有关于编程语言的知识。然而，我错得离谱。

我最初尝试学习Lisp时，一看到示例代码就放弃了。我想，和我一样的人肯定也有同样的想法：“为什么有人会想用这种语法如此可怕的语言？”我不愿意花时间去学习一门语法让人讨厌的语言。毕竟，我几乎被Lisp括号弄瞎了眼！

当我恢复视力时，我向一些Lisp教派成员表达了我的挫败感。几乎立刻，我就被一系列标准回应轰炸：Lisp的括号只是表面现象，Lisp的一个巨大优势是代码和数据以相同的方式表示（显然，这比XML要好得多），Lisp具有非常强大的元编程功能，允许程序编写代码并修改自身，Lisp允许创建针对特定问题的迷你语言，Lisp模糊了运行时和编译时的界限，Lisp，Lisp，Lisp...这个列表非常令人印象深刻。不用说，这些都没有道理。没有人能用具体的例子说明这些功能的有用之处，因为这些技术据说只在大型软件系统中有用。经过许多小时的争论，我放弃了。我不打算花几个月的时间去学习一门语法糟糕的语言，以便理解那些没有实际用途的晦涩功能。我的时机还没到。

几个月来，Lisp的拥护者们一直在努力。我感到困惑。我认识的许多非常聪明的人，我非常尊敬他们，他们几乎是以宗教般的热忱赞美Lisp。那里一定有什么东西，我不能不去探索！最终，我的求知欲战胜了我。我决定尝试，开始了几个月的思维锻炼。这是一段在无尽的挫败湖上的旅程。我把自己的思维翻过来，冲洗干净，然后放回原处。我经历了地狱的七个圈，然后回来了。然后我明白了。

顿悟是瞬间发生的。有那么一刻，我什么都不懂，下一刻，一切都豁然贯通了。我达到了涅槃。我无数次听到不同的人引用Eric Raymond的话：“学习Lisp是值得的，因为当你最终明白它时，你将获得深刻的启示；这种经历会让你在余生中成为一个更好的程序员，即使你实际上很少使用Lisp。”我从未理解过这句话。我从未相信过这是真的。最后，在经历了所有的痛苦之后，一切都说得通了！这句话比我想象的还要真实。我达到了一种几乎神圣的境界，一种瞬间的顿悟经历，让我在不到一秒钟的时间里颠覆了对计算机科学的看法。

就在那一刻，我成为了Lisp教派的一员。我感受到了一种忍者大师的感觉：在我的一生中，我必须把我新发现的知识传播给至少十个迷失的灵魂。我走上了通常的道路。我重复了给我讲解了几年的同样论点（只是现在它们真的有道理了！），希望能够转化为毫无戒心的旁观者。但这并没有奏效。我的坚持激起了一些人的兴趣，但他们在看到示例Lisp代码的一瞥之后，好奇心就消退了。也许经过多年的倡导，会有一些新的Lisp程序员，但我并不满足。一定有更好的方法。

我认真思考了这个问题。是什么让非常聪明、有经验的程序员难以理解Lisp？答案是否定的。毕竟，我明白了，如果我能做到，任何人都可以。那么，是什么让Lisp如此难以理解呢？答案，像这样的事情通常一样，出乎意料。当然！教任何人任何事都涉及在他们已经理解的概念基础上构建高级概念！如果过程有趣且解释得当，新概念就会变得和最初帮助理解的基本概念一样直观。这就是问题所在！元编程，代码和数据在一个表示中，自我修改的程序，特定领域的迷你语言，这些概念的解释都没有涉及熟悉的领域。我怎么能指望别人理解它们！难怪人们想要具体的例子。我可能一直在用火星文说话！

我和其他Lisp程序员分享了我的想法。他们说：“这些概念当然不是用熟悉的领域来解释的。它们是如此不同，与这些人以前学过的东西完全不同。”这是一个糟糕的借口。“我不相信这是真的，”我说。回应是一致的：“那你为什么不试试看？”于是我试了。这篇文章是我努力的成果。这是我用熟悉、直观的概念来解释Lisp的尝试。我敦促勇敢的灵魂继续阅读。拿起你最喜欢的饮料。深呼吸。准备好被震撼。哦，愿原力与你同在。

@section{XML重载}

千里之行，始于足下。通往启示之旅也不例外，我们的第一步恰好是XML。关于XML还有什么可以说的呢？事实证明，还有很多。虽然XML本身没有什么特别有趣的地方，但它与Lisp之间的关系却令人着迷。XML是Lisp拥护者们急需的那个非常熟悉的概念。它是我们向普通程序员传达理解的桥梁。所以让我们重新审视这个死马，拿出棍子，冒险进入以前从未敢涉足的XML荒野。是时候从另一个角度看看那个太熟悉的月亮了。

从表面上看，XML只是一种用于以人类可读的形式表示任意层次数据的标准化语法。待办事项列表、网页、医疗记录、汽车保险索赔、配置文件都是XML使用的潜在示例。让我们用一个简单的待办事项列表作为示例（在接下来的几节中，你会以全新的视角看待它）：

@pyblock{
<todo name="housework">
    <item priority="high">打扫房子。</item>
    <item priority="medium">洗碗。</item>
    <item priority="medium">买更多的肥皂。</item>
</todo>
}

如果我们对这个待办事项列表使用我们最喜欢的XML解析器，会发生什么？一旦数据被解析，它在内存中是如何表示的？最自然的表示方式当然是树——表示分层数据的完美数据结构。说到底，XML实际上只是一个序列化为人类可读形式的树。任何可以用树表示的东西都可以用XML表示，反之亦然。我希望你理解这个想法。这对接下来的内容非常重要。

让我们再深入一点。还有哪种类型的数据通常用树表示？这个问题的答案几乎是无穷无尽的，所以我给你一个提示——试着回忆一下你以前的编译器课程。如果你还记得源代码在解析后存储在树中，那么你就走在正确的道路上。任何编译器都会把源代码解析成一个抽象语法树。这并不奇怪，因为源代码是分层的：函数包含参数和代码块。代码块包含表达式和语句。表达式包含变量和运算符。如此这般。

让我们把这个推论应用到这个想法上。如果所有的源代码最终都表示为树，而任何树都可以序列化为XML，那么所有的源代码都可以转换为XML，对吗？让我们通过一个简单的例子来说明这个有趣的属性。考虑下面的函数：

@pyblock{
int add(int arg1, int arg2)
{
    return arg1 + arg2;
}
}

你能把这个函数定义转换成它的XML等价物吗？事实证明，这相当简单。当然，有很多方法可以做到这一点。以下是结果XML可能的一个样子：

@pyblock{
<define-function return-type="int" name="add">
    <arguments>
        <argument type="int">arg1</argument>
        <argument type="int">arg2</argument>
    </arguments>
    <body>
        <return>
            <add value1="arg1" value2="arg2" />
        </return>
    </body>
</define>
}

我们可以通过这个相对简单的练习来处理任何语言。我们可以把任何源代码转换成XML，然后把生成的XML转换回原始源代码。我们可以编写一个将Java转换为XML的转换器，然后编写一个将XML转换回Java的转换器。我们可以为C++做同样的事情。（如果你想知道是否有人疯狂到这种程度，看看@hyperlink["#" "GCC-XML"]）。此外，对于具有共同特性但使用不同语法的语言（在某种程度上，这对于大多数主流语言都是如此），我们可以使用XML作为中间表示来将源代码从一种语言转换为另一种语言。我们可以使用Java2XML转换器将Java程序转换为XML。然后我们可以在生成的XML上运行XML2CPP转换器，将其转换为C++代码。如果运气好（如果我们避免使用Java中不存在的C++功能），我们将获得一个可用的C++程序。很整洁，对吧？

所有这些实际上意味着我们可以使用XML来存储通用的源代码。我们将能够创建一整套使用统一语法的编程语言，以及编写将现有源代码转换为XML的转换器。如果我们真的采用这个想法，不同语言的编译器不需要实现特定的语法解析器——它们只需使用XML解析器将XML直接转换为抽象语法树。

现在，你可能想知道为什么我要发起这场XML十字军，以及它与Lisp有什么关系（毕竟，Lisp是在XML之前大约三十年创建的）。我保证一切都会很快变得清晰。但在我们迈出第二步之前，让我们进行一个小小的哲学练习。仔细看看上面的XML版本的@code{add}函数。你会如何分类它？是数据还是代码？如果你思考一下，你会发现把这个XML片段归入两个类别都有充分的理由。它是XML，它只是以标准化格式编码的信息。我们已经确定它可以从内存中的树数据结构生成（这实际上就是GCC-XML所做的）。它就在一个文件里，没有明显的执行方式。我们可以把它解析成一个XML节点树，并对其进行各种变换。它是数据。但等一下！说到底，它只是用不同语法编写的相同的@code{add}函数，对吧？一旦解析，它的树就可以输入到编译器中，我们就可以执行它。我们可以轻松地为这个XML代码编写一个小型解释器，并直接执行它。或者，我们可以把它转换成Java或C++代码，编译并运行它。它是代码。

那么，我们现在在哪里？看起来我们刚刚到达了一个有趣的地方。一个传统上一直很难理解的概念现在变得非常简单和直观。代码也总是数据！那么数据也总是代码吗？尽管这听起来很疯狂，但这很可能是真的。还记得我承诺过你会以全新的视角看待我们的待办事项列表吗？让我重申一下这个承诺。但我们现在还没有准备好讨论这个问题。现在让我们继续走下去。

稍早前，我提到我们可以轻松地为我们的XML片段中的@code{add}函数编写一个解释器。当然，这听起来像是一个纯粹的理论练习。谁会想为实际目的而这样做呢？事实证明，很多人会不同意。你可能至少在你的职业生涯中遇到过并使用过他们的作品。我让你坐在座位边缘了吗？如果是这样，让我们继续前进！

@section{Ant重载}

既然我们已经走到了月球的黑暗面，那就不要离开。我们还可以通过进一步探索它来学到一些东西，所以让我们再迈出一步。我们从闭上眼睛开始，回忆起2000年冬天一个寒冷的雨夜。一个杰出的开发者，名叫James Duncan Davidson[1]，正在研究Tomcat servlet容器。当需要构建更改时，他小心翼翼地保存了所有文件，然后运行了@code{make}。错误。很多错误。出了问题。经过仔细检查，James惊呼：“我的命令没有执行，是因为我在制表符前面有一个空格吗？”的确，这就是问题。又一次。James受够了。他能感觉到云层中的满月，这让他充满冒险精神。他创建了一个新的Java项目，迅速编写了一个简单但令人惊讶的有用的实用程序。这个天才之举使用Java属性文件来获取有关如何构建项目的信息。现在，James可以用一种漂亮的格式编写makefile的等价物，而不用再担心那些该死的空格了。他的实用程序通过解释属性文件并采取适当的行动来完成所有繁重的工作。这很整洁。另一个整洁的工具。Ant。

使用Ant构建Tomcat几个月后，很明显，Java属性文件不足以表示复杂的构建指令。需要检出、复制、编译文件，将其发送到另一台计算机并进行单元测试。如果失败，需要向适当的人发送电子邮件。如果成功，需要以最高可能的音量播放“Bad to the Bone”。在音轨结束时，音量需要恢复到原来的水平。是的，Java属性文件不再适用了。James需要一个更灵活的解决方案。他不想编写自己的解析器（尤其是因为他想要一个行业标准的解决方案）。XML似乎是一个合理的选择。几天后，Ant被移植到XML。这是自切片面包以来最好的事情。

那么，Ant是如何工作的呢？很简单。它接受一个带有特定构建指令的XML文件（你决定它们是数据还是代码），并通过为每个XML元素运行专门的Java代码来解释它们。实际上比听起来要简单得多。一个简单的XML指令，如下面的示例，会导致加载一个具有等效名称的Java类，并执行其代码。

@pyblock{
<copy todir="../new/dir">
    <fileset dir="src_dir"/>
</copy>
}

上面的片段将源目录复制到目标目录。Ant找到一个名为“@code{copy}”的任务（实际上是一个Java类），通过调用适当的Java方法设置适当的参数（@code{todir}和@code{fileset}），然后执行任务。Ant附带了一组核心任务，任何人都可以通过编写遵循某些约定的Java类来扩展它。Ant在遇到具有适当名称的XML元素时找到这些类并执行它们。非常简单。实际上，Ant完成了我们在上一节中讨论的内容：它充当了一种使用XML作为语法的语言的解释器，将XML元素转换为适当的Java指令。考虑到Ant是一个非常受欢迎的项目，上一节中提到的想法开始变得更加合理。毕竟，它们每天都在可能成千上万的公司中使用！

到目前为止，我还没有说为什么Ant实际上要费心解释XML。也不要试图在它的网站上寻找答案 - 你什么也找不到。至少与我们的讨论无关。让我们再迈出一步。是时候找出原因了。

@section{为什么选择XML？}

有时候，正确的决策是在没有完全意识到所有涉及的问题的情况下做出的。我不确定James是否知道为什么选择XML - 这可能是一个潜意识的决定。至少，在Ant的网站上我看到的关于使用XML的原因都是错误的原因。看起来主要的关注点围绕着可移植性和可扩展性。我不明白在Ant的情况下，XML如何有助于推进这些目标。使用解释过的XML与简单的Java源代码相比有什么优势？为什么不创建一组具有良好API的类，用于常用任务（复制目录、编译等），并直接从Java源代码中使用这些类？这将在运行Java的每个平台上运行（Ant无论如何都需要它），它具有无限的可扩展性，并且具有更愉快、熟悉的语法。那么为什么选择XML？我们能找到一个使用它的好理由吗？

事实证明，我们可以（尽管我之前提到过，我不确定James是否意识到这一点）。XML在引入语义结构方面具有比Java更灵活的属性。别担心，我不会陷入使用大词来描述难以理解的概念的陷阱。这实际上是一个相对简单的想法，尽管可能需要一些努力来解释。系好安全带。我们即将迈向实现涅槃的巨大飞跃。

我们如何在Java代码中表示上面的'@code{copy}'示例？以下是一种方法：

@pyblock{
CopyTask copy = new CopyTask();
Fileset fileset = new Fileset();

fileset.setDir("src_dir");
copy.setToDir("../new/dir");
copy.setFileset(fileset);

copy.execute();
}

代码几乎相同，尽管比原始XML稍微长一点。那么有什么不同呢？答案是XML片段为复制引入了一个特殊的语义结构。如果我们可以在Java中这样做，它看起来是这样的：

@pyblock{        
copy("../new/dir")
{
    fileset("src_dir");
}
}

你能看到区别吗？上面的代码（如果在Java中可能）是一个用于复制文件的特殊操作符 - 类似于一个@code{for}循环或Java 5中引入的新的@code{foreach}结构。如果我们有一个从XML到Java的自动转换器，它可能会生成上面的胡言乱语。这个原因是Java的接受语法树语法由语言规范固定 - 我们无法修改它。我们可以添加包、类、方法，但我们无法扩展Java以使添加新操作符成为可能。然而，我们可以尽情地在XML中这样做 - 它的语法树只受到我们解释器的限制！如果这个想法仍然不清楚，请考虑将一个特殊的操作符'@code{unless}'引入到Java中：
@section{几乎是Lisp}

暂时忘记操作符的问题，尝试扩展我们的视野，超越Ant设计的限制。我之前提到，Ant可以通过编写常规Java类来扩展。然后，Ant解释器尝试将XML元素与适当命名的Java类进行匹配，如果找到匹配项，则执行任务。一个有趣的问题值得提问。为什么不用Ant本身来扩展Ant呢？毕竟，核心任务包含许多常规编程语言结构（'if'就是一个很好的例子）。如果Ant提供了用Ant本身开发任务的构造，我们将达到更高程度的可移植性。我们将依赖一组核心任务（如果你愿意，可以称之为标准库），我们不关心Java运行时是否存在：核心集可以用任何东西实现。其余的任务将使用Ant-XML本身构建在核心之上。然后，Ant将成为一种通用的、可扩展的、基于XML的编程语言。考虑一下可能性：

@pyblock{
<task name="Test">
    <echo message="Hello World!"/>
</task>
<Test />
}

如果ant支持"@code{task}"构造，上面的示例将打印"Hello World!"。事实上，我们可以用Java编写一个"@code{task}"任务，并使Ant能够使用Ant-XML扩展自身！然后，Ant将能够在简单原语之上构建更复杂的原语，就像任何其他编程语言一样！这是我们在本教程开始时讨论的基于“XML”的编程语言的一个例子。不是很有用（你能说出为什么吗？）但相当酷。

顺便说一下，再看一下我们的'@code{Test}'任务。恭喜。你正在看Lisp代码。我在说什么？它看起来一点也不像Lisp？别担心，我们马上就会解决这个问题。困惑？好的，让我们澄清一切！

@section{更好的XML}

我在上一节中提到，自我扩展的Ant不会很有用。原因是XML的冗长。对于数据文件来说还不算太糟糕，但是一旦你尝试编写相当复杂的代码，你必须输入的数量很快就会变得非常繁琐，甚至无法用于任何实际项目。你有没有尝试过编写Ant构建脚本？我有过，一旦它们变得足够复杂，用XML来做这件事真的很烦人。想象一下，如果你必须在Java中输入几乎所有内容两次，因为你必须关闭每个元素。那不会让你疯掉吗？

解决这个问题的方法是使用XML的简洁替代品。请记住，XML只是一种表示分层数据的格式。我们不必使用XML的尖括号来序列化树。我们可以想出许多其他格式。其中一种格式（顺便说一下，Lisp使用的格式）称为s表达式。S表达式实现了与XML相同的目标。它们只是不那么冗长，这使得它们更适合输入代码。过一会儿我会解释s表达式，但在我这样做之前，我必须澄清关于XML的一些事情。让我们考虑一下我们用于复制文件的XML示例：

@pyblock{
<copy todir="../new/dir">
    <fileset dir="src_dir"/>
</copy>
}

想象一下这段代码片段在内存中的解析树是什么样子的。我们会有一个'copy'节点，其中包含一个fileset节点。但属性呢？它们如何适应我们的图景？如果你曾经使用XML来描述数据，并想知道你应该使用元素还是属性，你并不孤单。没有人真正能弄清楚这个问题，正确地做到这一点往往是黑魔法而不是科学。原因是属性实际上是元素的子集。属性可以做的任何事情，元素也可以做。引入属性的原因是为了遏制XML的冗长。看看我们的'copy'片段的另一个版本：

@pyblock{
<copy>
    <todir>../new/dir</todir>
    <fileset>
        <dir>src_dir</dir>
    </fileset>
</copy>
}

这两个片段包含了完全相同的信息。然而，我们使用属性来避免多次输入相同的内容。想象一下，如果属性不是XML规范的一部分，用XML编写任何东西都会让我们抓狂！

现在我们已经解决了属性的问题，让我们看看s表达式。我们绕道的原因是s表达式没有属性。因为它们不那么冗长，属性简单地不需要。这是我们在将XML转换为s表达式时需要记住的一件事。让我们看一个例子。我们可以像这样将上面的片段翻译成s表达式：

@codeblock{
(copy
    (todir "../new/dir")
    (fileset (dir "src_dir")))
}

仔细看看这个表示。有什么不同？尖括号似乎被括号取代了。我们只是跳过了"(element"中的第二个括号，然后继续。元素然后像这样关闭：")"。就是这样！翻译是自然而简单的。输入起来也容易得多。括号会让第一次使用的用户眼花缭乱吗？也许，但现在我们理解了它们背后的原理，它们更容易处理。至少它们比XML的关节炎诱发冗长要好。在习惯了s表达式之后，用它们编写代码不仅可行，而且非常愉快。而且它们提供了用XML编写代码的所有优点（其中许多我们尚未探讨）。让我们看看我们的'task'代码，它看起来更像lisp：

@codeblock{
(task (name "Test")
    (echo (message "你好，世界！")))

(Test)
}

S表达式在Lisp术语中被称为列表。考虑一下我们上面的'task'元素。如果我们不换行，用逗号代替空格，它开始看起来像一个元素和其他列表的列表（格式化是为了更容易看到嵌套的列表）：

@codeblock{
(task, (name, "test"), (echo, (message, "你好，世界！")))
}

我们可以对XML做同样的事情。当然，上面的行实际上不是一个列表，它是一个树，就像它的XML替代品一样。不要让对列表的引用混淆你，这只是因为包含其他列表的列表和树实际上是相同的东西。Lisp可能代表列表处理，但它实际上是树处理 - 与处理XML节点没有什么不同。

哇。经过长时间的胡言乱语，我们终于得到了一些看起来像Lisp（实际上是Lisp）的东西。现在，神秘的Lisp括号以及Lisp支持者的一些说法应该变得更加清晰了。但我们还有很多工作要做。准备好了吗？让我们继续吧！

@section{C宏重新加载}

现在，你一定已经厌倦了所有的XML讨论。我也很累了。现在是时候从所有的树、s表达式和Ant业务中休息一下了。相反，让我们回到每个程序员的根源。现在是讨论C预处理器的时候了。我听到你问C与任何事情有什么关系？好吧，我们现在已经知道足够的内容来进行元编程，并讨论编写其他代码的代码。理解这个往往很难，因为所有的教程都是用你不知道的语言来讨论它。但是，这个概念并不难。我相信基于C的元编程讨论会使整个过程更容易理解。所以，让我们看看（双关语）。

为什么有人想编写一个编写程序的程序？我们如何在现实世界中使用这样的东西？到底什么是元编程？你已经知道所有的答案，只是你还不知道。为了解锁神秘知识的隐藏宝库，让我们考虑一个相当平凡的任务，即从代码中简单地访问数据库。我们都经历过这个过程。在代码中编写SQL查询以修改表中的数据很快就会变成重复的地狱。即使使用新的C# 3.0 LINQ，这也是一个巨大的痛苦。编写完整的SQL查询（虽然有一个很好的内置语法）来获取某人的姓名或修改某人的地址并不是程序员的舒适之选。我们该怎么解决这些问题？进入数据访问层。

这个想法很简单。通过创建一组类来抽象数据库访问（至少是微不足道的查询），这些类与数据库中的表相对应，并使用访问器方法来执行实际的查询。这极大地简化了开发——我们不再编写SQL查询，而是进行简单的方法调用（或属性赋值，这取决于你选择的语言）。任何使用过最简单的数据访问层的人都知道它可以节省多少时间。当然，任何编写过数据访问层的人都知道它可以浪费多少时间——编写一组类来镜像表并将访问器转换为SQL查询需要花费相当长的时间。这似乎特别愚蠢，因为大部分工作都是手动完成的：一旦你找到了设计并开发了一个典型的数据访问类的模板，你就不需要思考了。你只需要基于相同的模板一遍又一遍地编写代码。许多人发现有更好的方法——有很多工具可以连接到数据库，获取模式，并根据预定义的（或自定义的）模板为你编写代码。

任何使用过这种工具的人都知道它可以节省多少时间。在几个点击中，你将工具连接到数据库，让它生成数据访问层源代码，将文件添加到你的项目中，然后voilà——十分钟的工作比以前需要数百个人小时的工作做得更好。如果你的数据库模式发生了变化会发生什么？好吧，你只需要再次经历这个简短的过程。当然，一些最好的工具让你自动化这个过程——你只需要将它们添加为你的构建步骤的一部分，每次编译你的项目时，一切都会自动完成。这是完美的！你几乎什么都不用做。如果模式发生了变化，你的数据访问层代码会在编译时自动更新，任何过时的访问都会导致编译器错误！


数据访问层是一个很好的例子，但还有很多其他的例子。从样板GUI代码，到Web代码，到COM和CORBA存根，到MFC和ATL，-有很多例子，其中相同的代码一遍又一遍地编写。由于编写这些代码是可以完全自动化的任务，而程序员的时间比CPU时间昂贵得多，因此已经创建了许多工具，可以自动生成这些样板代码。这些工具到底是什么？嗯，它们是编写程序的程序。它们执行一个简单的任务，具有元编程的神秘名称。就是这样。

我们可以在数百万种情况下创建和使用这些工具，但更多的情况是我们不这样做。归根结底，这是一个潜意识的计算-如果我只需要写这些非常相似的部分约七次，那么为我创建一个单独的项目，编写一个完整的工具来生成某些东西，然后使用它是否值得？当然不是。数据访问层和COM存根被写了数百次，数千次。这就是为什么有工具为它们服务。对于重复次数仅为几次，甚至几十次的类似代码，编写代码生成工具甚至不被考虑。创建这样的工具的麻烦往往远远超过使用它的好处。如果只有创建这样的工具更容易，我们可以更经常地使用它们，并节省许多时间。让我们看看是否可以以合理的方式实现这一点。

令人惊讶的是，C预处理器挺身而出。我们都在C和C++中使用过它。偶尔我们都希望Java也有它。我们使用它在编译时执行简单的指令，以对我们的代码进行小的更改（例如选择性地删除调试语句）。让我们看一个快速的例子：

@pyblock{
#define triple(X)    X + X + X
}


这行代码做了什么？这是一个简单的指令，用预处理器语言编写，指示它将所有@code{triple(X)}的实例替换为@code{X + X + X}。例如，所有@code{triple(5)}的实例都将被替换为@code{5 + 5 + 5}，然后由C编译器编译生成的代码。我们在这里实际上正在进行一种非常原始的代码生成。如果C预处理器更强大一些，并包括连接到数据库和一些更简单的结构的方法，我们可以在程序中使用它来开发我们的数据访问层！考虑以下使用C预处理器的虚构扩展的示例：

@pyblock{
#get-db-schema("127.0.0.1, un, pwd");
#iterate-through-tables
#for-each-table
    class #table-name
    {
    };
#end-for-each
}

我们刚刚连接到数据库模式，遍历了所有的表，并为每个表创建了一个空类。所有这些都在我们的源代码中的几行内完成！现在，每次重新编译包含上述代码的文件时，我们都会得到一组新构建的类，这些类会根据模式自动更新。稍加想象，您就可以看到我们如何可以直接从程序中构建完整的数据访问层，而无需使用任何外部工具！当然，这有一定的缺点（除了这样一个高级版本的C预处理器不存在的事实之外）-我们必须学习一个全新的“编译时语言”来完成这样的工作。对于复杂的代码生成，这种语言也必须非常复杂，它必须支持许多库和语言结构。例如，如果我们生成的代码依赖于位于某个ftp服务器上的某个文件，则预处理器必须能够连接到ftp。为此而创建和学习一种新语言是一件遗憾的事情。特别是因为已经有这么多好的语言了。当然，如果我们添加一些创意，我们可以轻松避免这个陷阱。

为什么不用C/C++本身替换预处理器语言？我们将在编译时拥有语言的全部功能，我们只需要学习一些简单的指令来区分编译时和运行时代码！

@pyblock{
<%
    cout << "Enter a number: ";
    cin >> n;
%>
for(int i = 0; i < <%= n %>; i++)
{
    cout << "hello" << endl;
}
}

你看到这里发生了什么吗？在<%和%>标记之间的所有内容在程序编译时运行。任何在这些标记之外的内容都是正常的代码。在上面的示例中，您将在开发环境中开始编译程序。标记之间的代码将被编译，然后运行。您将得到一个提示输入数字。您将输入一个数字，然后将其放入for循环中。然后for循环将像往常一样被编译，您将能够执行它。例如，如果您在编译程序时输入5，则生成的代码将如下所示：

@section{Hello, Lisp!}

到目前为止，我们所学的关于Lisp的一切都可以用一句话概括：Lisp是可执行的XML，具有更友好的语法。我们还没有讨论Lisp的实际操作。现在是填补这个空白的时候了[2]。

Lisp有许多内置数据类型。例如，整数和字符串与您所熟悉的并没有太大的区别。71或“hello”的含义在Lisp中与在C++或Java中大致相同。对我们更感兴趣的是符号、列表和函数。我将在本节的其余部分描述这些数据类型以及Lisp环境如何编译和执行您键入到其中的源代码（在Lisp术语中，这称为评估）。在一个整体中理解这个部分对于理解Lisp元编程的真正潜力、代码和数据的统一以及特定领域语言的概念非常重要。不要把这个部分看作是一项任务，我会尽力让它有趣和易于理解。希望您能在学习的过程中获得一些有趣的想法。好的，让我们从Lisp的符号开始。

在Lisp中，符号大致相当于C++或Java的标识符概念。它是一个名称，您可以使用它来访问变量（例如currentTime、arrayCount、n等）。不同之处在于，Lisp中的符号比其主流标识符替代品更自由。在C++或Java中，您只能使用字母数字字符和下划线。在Lisp中，您不是这样的。例如，+是一个有效的符号。-、=、hello-world、hello+world、*等也是有效的符号（您可以在网上找到有效的Lisp符号的确切定义）。您可以将任何数据类型分配给这些符号。现在让我们忽略Lisp语法并使用伪代码。假设一个函数set将某个值分配给一个符号（就像Java或C++中的=一样）。以下都是有效的示例：

@pyblock{
set(test, 5)            // 符号“test”将等于整数5
set(=, 5)               // 符号“=”将等于整数5
set(test, "hello")      // 符号“test”将等于字符串“hello”
set(test, =)            // 此时符号“=”等于5
                        // 因此符号“test”将等于5
set(*, "hello")         // 符号“*”将等于字符串“hello”
}



如果我们可以将字符串和整数分配给像*这样的符号，那么Lisp如何进行乘法运算呢？毕竟，*表示乘法，对吧？答案很简单。Lisp中的函数并不特殊。有一种数据类型，函数，就像整数和字符串一样，可以分配给符号。乘法函数内置于Lisp中，并分配给符号*。您可以重新分配不同的值给*，这样您就会失去乘法函数。或者，您可以将函数的值存储在其他变量中。再次使用伪代码：

@pyblock{
*(3, 4)                 // 将3乘以4，结果为12
set(temp, *)            // 符号'*'等于乘法函数
                        // 因此temp将等于乘法函数
set(*, 3)               // 将符号'*'设置为等于3
*(3, 4)                 // 错误，符号'*'不再等于函数
                        // 它等于3
temp(3, 4)              // temp等于乘法函数
                        // 因此Lisp将3乘以4，结果为12
set(*, temp)            // 符号'*'再次等于乘法函数
*(3, 4)                 // 将3乘以4，结果为12
}

您甚至可以做一些奇怪的事情，例如将加号重新分配为减号：

@pyblock{
set(+, -)               // '-'的值是内置的减法函数
                        // 因此现在符号'+'等于减法函数
+(5, 4)                 // 由于符号'+'等于减法函数
                        // 这将导致1
}

我在这些示例中非常自由地使用了函数，但我还没有描述它们。Lisp中的函数只是像整数、字符串或符号一样的数据类型。函数没有像Java或C++中那样的名称概念。相反，它独立存在。实际上，它是指向一块代码块的指针以及一些信息（例如它接受的参数数量）。您只需通过将其分配给符号来为函数命名，就像分配整数或字符串一样。您可以使用用于创建函数的内置函数之一来创建函数，将其分配给符号'fn'。使用伪代码：

@pyblock{
fn [a]
{
    return *(a, 2);
}
}

这将返回一个函数，它接受一个名为'a'的单个参数并将其加倍。请注意，该函数没有名称，但是您可以将其分配给符号：

@pyblock{
set(times-two, fn [a] { return *(a, 2); })
}

现在我们可以调用此函数：

@pyblock{
times-two(5)             // 返回10
}

现在我们已经了解了符号和函数，那么列表呢？好吧，您已经对它们了解了很多。列表只是以s表达式形式编写的XML片段。列表由括号指定，并包含由空格分隔的Lisp数据类型（包括其他列表）。例如（这是真正的Lisp，注意我们现在使用分号进行注释）：

@codeblock{
()                      ; 空列表
(1)                     ; 一个只有一个元素1的列表
(1 "test")              ; 一个有两个元素的列表
                        ; 一个整数1和一个字符串"test"
(test "hello")          ; 一个有两个元素的列表
                        ; 符号test和字符串"hello"
(test (1 2) "hello")    ; 一个有三个元素的列表，一个符号test
                        ; 一个由两个整数1和2组成的列表
                        ; 和一个字符串"hello"
}

当Lisp系统在源代码中遇到列表时，它的行为与Ant在遇到XML时完全相同-它尝试执行它们。实际上，Lisp源代码只使用列表指定，就像Ant源代码只使用XML指定一样。Lisp以以下方式执行列表。列表的第一个元素被视为函数的名称。其余的元素被视为函数参数。如果其中一个参数是另一个列表，则使用相同的原则执行它，并将结果作为参数传递给原始函数。就是这样。我们现在可以编写真正的代码了：

@codeblock{
(* 3 4)                 ; 等同于伪代码*(3, 4)。
                        ; 符号'*'是一个函数
                        ; 3和4是它的参数。
                        ; 返回12。
(times-two 5)           ; 返回10
(3 4)                   ; 错误：3不是函数
(times-two)              ; 错误，times-two需要一个参数
(times-two 3 4)          ; 错误，times-two需要一个参数
(set + -)               ; 将符号'+'设置为等于符号'-'的值
                        ; 等于减法函数
(+ 5 4)                 ; 返回1，因为符号'+'现在相当于减法函数
(* 3 (* 2 2))           ; 将3乘以第二个参数
                        ; （这是一个返回4的函数调用）。
                        ; 返回12。
}

请注意，到目前为止，我们指定的每个列表都被Lisp系统视为代码。但是，我们如何将列表视为数据？再次想象一个接受XML作为其参数之一的Ant任务。在Lisp中，我们使用引号运算符'来执行此操作：

@codeblock{
(set test '(1 2))       ; test等于一个由两个整数1和2组成的列表
(set test (1 2))        ; 错误，1不是函数
(set test '(* 3 4))     ; 将test设置为由三个元素组成的列表，
                        ; 一个符号*，一个整数3和一个整数4
}

我们可以使用内置函数head返回列表的第一个元素，使用内置函数tail返回列表的其余元素：
@codeblock{
(head '(* 3 4))         ; returns a symbol '*'
(tail '(* 3 4))         ; returns a list (3 4)
(head (tail '( * 3 4))) ; (tail '(* 3 4)) returns a list (3 4)
                        ; and (head '(3 4)) returns 3.
(head test)             ; test was set to a list in previous example
                        ; returns a symbol '*'
}

You can think of built in Lisp functions as you think of Ant tasks. The difference 
is that we don't have to extend Lisp in another language (although we can), we 
can extend it in Lisp itself as we did with the times-two example. Lisp comes 
with a very compact set of built in functions - the necessary minimum. The rest 
of the language is implemented as a standard library in Lisp itself.

@section{Lisp宏}

到目前为止，我们已经从简单的类似于JSP的模板引擎的角度来看待元编程。我们使用简单的字符串操作进行代码生成。这通常是大多数代码生成工具处理此任务的方式。但是我们可以做得更好。为了走上正确的轨道，让我们从一个问题开始。如何编写一个工具，通过查看目录结构中的源文件自动生成Ant构建脚本？

我们可以采取简单的方法，通过操作字符串来生成Ant XML。当然，更抽象，更具表现力和可扩展性的方法是使用XML处理库直接在内存中生成XML节点。然后可以自动将节点序列化为字符串。此外，我们的工具将能够通过加载它们并直接处理XML节点来分析和转换现有的Ant构建脚本。我们将自字符串中抽象出来，并处理更高级别的概念，这让我们更快，更容易地完成工作。

当然，我们可以编写Ant任务，以允许处理XML转换，并在Ant本身中编写我们的生成工具。或者我们可以使用Lisp。正如我们之前看到的，列表是内置的Lisp数据结构，Lisp具有许多快速有效地处理列表的工具（head和tail是最简单的工具）。此外，Lisp没有语义约束-您可以使您的代码（和数据）具有任何结构。

在Lisp中，元编程是使用称为“宏”的构造完成的。让我们尝试开发一组宏，将数据（例如待办事项列表）转换为处理待办事项列表的语言。

让我们回想一下待办事项列表示例。XML如下：

@pyblock{
<todo name="housework">
    <item priority="high">Clean the house.</item>
    <item priority="medium">Wash the dishes.</item>
    <item priority="medium">Buy more soap.</item>
</todo>
}

相应的s表达式版本如下：

@codeblock{
(todo "housework"
    (item (priority high) "Clean the house.")
    (item (priority medium) "Wash the dishes.")
    (item (priority medium) "Buy more soap."))
}

假设我们正在编写一个待办事项管理应用程序。我们将待办事项项序列化为一组文件，并在程序启动时读取它们并将它们显示给用户。我们如何使用XML和其他语言（例如Java）实现这一点？我们将使用一些XML解析器解析我们的待办事项列表的XML文件，编写遍历XML树并将其转换为Java数据结构的代码（因为在Java中处理DOM很麻烦），然后使用此数据结构来显示数据。现在，我们如何在Lisp中完成相同的事情？

如果我们采用相同的方法，我们将使用负责解析XML的Lisp库解析文件。然后，XML将以Lisp列表（s表达式）的形式呈现给我们，我们将遍历列表并向用户呈现相关数据。当然，如果我们使用Lisp，将数据直接持久化为s表达式是有意义的，因为没有理由进行XML转换。我们不需要特殊的解析库，因为作为一组s表达式持久化的数据是有效的Lisp，我们可以使用Lisp编译器将其解析并将其存储在内存中作为Lisp列表。请注意，Lisp编译器（就像.NET编译器一样）在Lisp程序运行时可用。

但是我们可以做得更好。我们可以编写一个宏，使我们能够将数据视为代码！宏是如何工作的？非常简单。回想一下，Lisp函数是这样调用的：

@codeblock{
(function-name arg1 arg2 arg3)
}

Where each argument is a valid Lisp expression that's evaluated and passed to the 
function. For example if we replace arg1 above with (+ 4 5), it will be evaluated 
and 9 would be passed to the function. A macro works the same way as a function, 
except its arguments are not evaluated.

@codeblock{
(macro-name (+ 4 5))
}

在这种情况下，(+ 4 5)不会被评估，并作为列表传递给宏。然后，宏可以自由地对其进行操作，包括对其进行评估。宏的返回值是一个Lisp列表，被视为代码。宏的原始位置将被替换为此代码。例如，我们可以定义一个名为plus的宏，它接受两个参数并放入将它们相加的代码。

这与元编程和待办事项列表问题有什么关系？好吧，首先，宏是使用列表抽象生成代码的小代码块。此外，我们可以创建名为to-do和item的宏，用我们喜欢的任何代码替换我们的数据，例如向用户显示项目的代码。

这种方法提供了什么好处？我们不必遍历列表。编译器将为我们执行此操作，并将调用适当的宏。我们需要做的就是创建将我们的数据转换为适当代码的宏！

例如，类似于我们之前展示的三重C宏的宏如下所示：

@codeblock{
(defmacro triple (x)
    '(+ ~x ~x ~x))
}

引号防止评估，而波浪号允许它。现在，每次在Lisp代码中遇到triple时：

@codeblock{
(triple 4)
}

它将被替换为以下代码：

@codeblock{
(+ 4 4 4)
}


We can create macros for our to-do list items that will get called by lisp 
compiler and will transform the to-do list into code. Now our to-do list will 
be treated as code and will be executed. Suppose all we want to do is print it 
to standard output for the user to read:

@codeblock{
(defmacro item (priority note)
    '(block
         (print stdout tab "优先级: "
             ~(head (tail priority)) endl)
         (print stdout tab "备注: " ~note endl endl)))
}

我们刚刚在Lisp中创建了一个非常小且有限的语言，用于管理待办事项列表。这样的语言非常特定于特定的问题域，通常称为特定领域语言或DSL。

@section{特定领域语言}

在本文中，我们已经遇到了两种特定领域语言：Ant（专门用于处理项目构建）和我们未命名的小型语言，用于处理待办事项列表。区别在于，Ant是使用XML、XML解析器和Java从头开始编写的，而我们的语言嵌入到Lisp中，并且可以在几分钟内轻松创建。

我们已经讨论了DSL的好处，主要是为什么Ant使用XML而不是Java源代码。Lisp允许我们为问题创建任意数量的DSL。我们可以为创建Web应用程序、编写大规模多人游戏、进行固定收益交易、解决蛋白质折叠问题、处理交易等领域创建特定领域语言。我们可以将这些语言层叠在一起，并通过利用我们的Web应用程序语言和债券交易语言创建用于编写基于Web的交易应用程序的语言。每天我们都会获得这种方法的好处，就像我们获得Ant的好处一样。

使用DSL解决问题会产生更紧凑、可维护、灵活的程序。在Java中，我们通过创建帮助我们解决问题的类来创建它们。区别在于，Lisp允许我们将这种抽象提升到更高的层次：我们不受Java解析器的限制。想象一下使用某个支持库在Java本身中编写构建脚本。将其与使用Ant进行比较。现在将此比较应用于您曾经处理过的每个问题，您将开始窥见Lisp提供的一小部分好处。


@section{接下来做什么？}

学习Lisp是一场艰苦的战斗。尽管在计算机科学术语中，Lisp是一种古老的语言，但迄今为止很少有人能够很好地教授它，使其易于理解。尽管许多Lisp倡导者做出了巨大努力，但今天学习Lisp仍然很困难。好消息是，这种情况不会永远存在，因为与Lisp相关的资源数量正在迅速增加。时间站在Lisp这边。

Lisp是摆脱平庸并领先于其他人的一种方式。学习Lisp意味着您今天可以获得更好的工作，因为您可以向任何合理聪明的面试官展示对软件工程大多数方面的新见解。这也意味着您明天可能会被解雇，因为每个人都厌倦了您不断提到如果公司的软件只是用Lisp编写，它就可以做得更好。这值得努力吗？每个学习Lisp的人都会说是的。当然，选择仍然取决于您。

@section{评论？}

哇。够了。我已经断断续续地写了这篇文章几个月了。如果您觉得它有趣，有任何问题、评论或建议，请在@hyperlink["#" "coffeemug@gmail.com"]留言。我很乐意听取您的反馈。

[1] 我从未见过詹姆斯，他也不知道我的存在。这个故事完全是虚构的，基于我在互联网上找到的有关Ant历史的一些帖子。

[2] Lisp有许多不同的方言（最流行的是Common Lisp和Scheme）。每种方言都以不同的方式处理复杂的细节，但共享相同的基本原则。由于本文的目标是让您了解Lisp的原则，因此我将使用Blaise作为示例（在撰写本文时，它是虚构的）。通过一些小的修改，这些示例可以翻译成其他Lisp方言。
